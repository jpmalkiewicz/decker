english
	ENGINE.addTableRow = FUNCTION (table)
		// create the new table row
		LOCAL.row = ARRAY
		table.cell[] = row
		LOCAL.i = 0
		LOCAL.columns = table.columns
		LOCAL.k = UNDEFINED
		LOCAL.can_expand = UNDEFINED
		while i < columns
			k = argument[i+1]
			// if it's not a structure, wrap a COMPONENT around it so we can set its position within the table cell
			if value_type(k) != "STRUCTURE" && k != UNDEFINED
				k = COMPONENT
					component = k
			row[] = k
			// use the default values for all undefined cell values
			if k != UNDEFINED
				can_expand = isExpandable(k)
				if k.x == UNDEFINED && table.cell_x != UNDEFINED && ( can_expand || hasVariable(k,"x") )
					if value_type(table.cell_x) == "CONSTANT"
						k.x = table.cell_x
					else
						k.x = table.cell_x[i]
				if k.y == UNDEFINED && table.cell_y != UNDEFINED && ( can_expand || hasVariable(k,"y") )
					if value_type(table.cell_y) == "CONSTANT"
						k.y = table.cell_y
					else
						k.y = table.cell_y[i]
				if k.v_align == UNDEFINED && table.cell_v_align != UNDEFINED && ( can_expand || hasVariable(k,"v_align") )
					if value_type(table.cell_v_align) == "CONSTANT"
						k.v_align = table.cell_v_align
					else
						k.v_align = table.cell_v_align[i]
				if k.h_align == UNDEFINED && table.cell_h_align != UNDEFINED && ( can_expand || hasVariable(k,"h_align") )
					if value_type(table.cell_h_align) == "CONSTANT"
						k.h_align = table.cell_h_align
					else
						k.h_align = table.cell_h_align[i]
			i = i + 1
		// adjust the table size
		table.rows = table.cell.size
		table.height = table.cell_height * table.rows
		
		
	// creates a border with the given values
	ENGINE.createBorder = FUNCTION (bx, by, bwidth, bheight, bbackground_color, binverted, bcolor1, bcolor2)
		return_value = BORDER
			x        = &bx
			y        = &by
			width    = &bwidth
			height   = &bheight
			background_color = &bbackground_color
			inverted = binverted == true
			if &bcolor1 != UNDEFINED
				top_color = &bcolor1
			if &bcolor2 != UNDEFINED
				bottom_color = &bcolor2
			
	
	ENGINE.createScrollbar = FUNCTION (_x, _y, _width, _height, _vertical, _slider, _slider_max, _up_left_arrow, _down_right_arrow, _slider_stepping, _slider_position)
		return_value = SCROLLBAR
			x = _x
			y = _y
			width = _width
			height = _height
			vertical = _vertical != false
			if _slider_stepping != UNDEFINED
				slider_stepping = _slider_stepping
			if _slider_max != UNDEFINED
				slider_max = _slider_max
			// add the slider and the optional arrow buttons
			if value_type(_slider) == "STRING"      // it's the name of an image. we need to turn it into a button
// !!
//				debug("a")
				LOCAL.b = _slider
//				debug("b")
// !! end
				_slider = BUTTON
					idle = b
//					idle = _slider
//				debug(_slider)
			if vertical
				_slider.x = CENTER
				_slider.y = 0   // the y position is adjusted every time the SCROLLBAR is drawn. this way it can adjust to mods with different sized buttons
			else
				_slider.x = 0
				_slider.y = CENTER  // the x position is adjusted every time the SCROLLBAR is drawn. this way it can adjust to mods with different sized buttons
			_slider.on_mouse_down = FUNCTION (mouse_x, mouse_y)
				SCROLLBAR.slider_dragging = vertical ? mouse_y : mouse_x
			component[0] = _slider
			if _up_left_arrow != UNDEFINED
				if value_type(_up_left_arrow) == "STRING"      // it's the name of an image. we need to turn it into a button
					_up_left_arrow = BUTTON
						idle = _up_left_arrow
				if vertical
					_up_left_arrow.x = CENTER
					_up_left_arrow.y = 0
				else
					_up_left_arrow.x = 0
					_up_left_arrow.y = CENTER
				_up_left_arrow.on_mouse_down = FUNCTION
					setSliderPosition(SCROLLBAR.this, slider_position - slider_stepping)
				component[1] = _up_left_arrow
			if _down_right_arrow != UNDEFINED
				if value_type(_down_right_arrow) == "STRING"      // it's the name of an image. we need to turn it into a button
					_down_right_arrow = BUTTON
						idle = _down_right_arrow
				if vertical
					_down_right_arrow.x = CENTER
					_down_right_arrow.y = BOTTOM
				else
					_down_right_arrow.x = RIGHT
					_down_right_arrow.y = CENTER
				_down_right_arrow.on_mouse_down = FUNCTION
					setSliderPosition(SCROLLBAR.this, slider_position + slider_stepping)
				component[2] = _down_right_arrow


	// image_array must contain 1-3 entries : [0] the slider, [1] the up/left arrow, [2] the down/right arrow
	ENGINE.createSimpleScrollbar = FUNCTION (boundingwidth, boundingheight, image_array, vertical)
		if vertical
			return_value = createScrollbar(RIGHT, 0, , boundingheight, true, image_array[0], 0, image_array[1], image_array[2])
		else
			return_value = createScrollbar(0, BOTTOM, boundingwidth, , false, image_array[0], 0, image_array[1], image_array[2])
				

	ENGINE.createTable = FUNCTION (pcolumns, pcell_height, pcell_width)
		return_value = TABLE
			columns = &pcolumns
			cell_height = &pcell_height
			if argument.size == 3
				cell_width = pcell_width
			else
				cell_width = ARRAY
				LOCAL.i = 2
				while i < argument.size
					width = width + argument[i]  // the width of the table
					cell_width[] = &argument[i]
					i = i + 1
				columns = cell_width.size


	// returns a new TEXT with the default settings as defined in the TEXT stored in TEXT_STYLE
	ENGINE.createText = FUNCTION (text, x, y, color, font, h_align, v_align, width, height)
		return_value = copy(@TEXT_STYLE)
		// for all settings which are not defined, the default settings will be used
		if text != UNDEFINED
			return_value.text = &text
		if x != UNDEFINED
			return_value.x = &x
		if y != UNDEFINED
			return_value.y = &y
		if color != UNDEFINED
			return_value.color = &color
		if font != UNDEFINED
			return_value.font = &font
		if h_align != UNDEFINED
			return_value.h_align = &h_align
		if v_align != UNDEFINED
			return_value.v_align = &v_align
		if width != UNDEFINED
			return_value.v_align = &width
		if height != UNDEFINED
			return_value.v_align = &height
			
	
	// returns a new TEXT with the default settings as defined in the TEXT stored in TEXT_STYLE
	ENGINE.createTextBold = FUNCTION (text, x, y, color, font)
		return_value = copy(@TEXT_STYLE_BOLD)
		// for all settings which are not defined, the default settings will be used
		if x != UNDEFINED
			return_value.x = &x
		if y != UNDEFINED
			return_value.y = &y
		if color != UNDEFINED
			return_value.color = &color
		if font != UNDEFINED
			return_value.font = &font


	// returns the name of the image to be displayed, deducing it from the state "0" image. e.g. deduceImageName("my_button0", "1") will return "my_button1" if an image "my_button1.*" exists, otherwise it returns "my_button0"
	ENGINE.deduceImageName = FUNCTION (base_name, new_suffix)
		return_value = base_name
		// make sure it's not a structure. if it's a structure, just return it
		if base_name.structure_type == UNDEFINED
			base_name = base_name + ""    // turns it into a string
			LOCAL.k = indexof("0", base_name, false)
			return_value = base_name
			// check whether there's a "0" suffix, possibly followed by a supported image file type extension
			if k != UNDEFINED
				if k == size(base_name)-1
					// the "0" sits at the end of the string
					if image_exists(substring(base_name,0,k) + new_suffix)
						return_value = substring(base_name,0,k) + new_suffix
				else
					// check whether there's a file type extension after the "0", otherwise the "0" is not a suffix and we'll just return the base_name
					LOCAL.file_type = to_lower_case(base_name.substring(k+1))
					if file_type == ".gif" || file_type == ".png" || file_type == ".bmp" ||file_type == ".jpg" || file_type == ".jpeg"
						if image_exists(substring(base_name,0,k) + new_suffix)
							return_value = substring(base_name,0,k) + new_suffix


	ENGINE.scrollbarDrawFunction = FUNCTION (_scrollbar)
		if _scrollbar.vertical
			LOCAL.physical_range = _scrollbar.height - pixelheight(_scrollbar.component[0]) - pixelheight(_scrollbar.component[1]) - pixelheight(_scrollbar.component[2])
			_scrollbar.component[0].y = pixelheight(_scrollbar.component[1]) + (physical_range * _scrollbar.slider_position + _scrollbar.slider_max/2) / _scrollbar.slider_max
		else
			LOCAL.physical_range = _scrollbar.width - pixelwidth(_scrollbar.component[0]) - pixelwidth(_scrollbar.component[1]) - pixelwidth(_scrollbar.component[2])
			_scrollbar.component[0].x = pixelwidth(_scrollbar.component[1]) + (physical_range * _scrollbar.slider_position + _scrollbar.slider_max/2) / _scrollbar.slider_max
	
	
	// sets a line to the given values. this function purely exists to simplify scripts
	ENGINE.setLine = FUNCTION (line, x, y, x2, y2, color)
		line.x     = &x
		line.y     = &y
		line.x2    = &x2
		line.y2    = &y2
		line.color = &color


	// moves the slider of a scrollbar to a new logical position
	ENGINE.setSliderPosition = FUNCTION (_scrollbar, _slider_position)
		// the logical slider position cannot be negative
		if _slider_position < 0
			_slider_position = 0
		// make sure it really is a scrollbar
		if _scrollbar.slider_position != UNDEFINED && _scrollbar.slider_position != _slider_position
			// the logical slider position cannot exceed the slider_max setting for the scrollbar
			if _slider_position > _scrollbar.slider_max
				_slider_position = _scrollbar.slider_max
			// make sure the slider position isn't the same as before, before you change it
			if _slider_position != _scrollbar.slider_position
				_scrollbar.slider_position = _slider_position
			if _scrollbar.effect != UNDEFINED
				_scrollbar.effect(_scrollbar, _scrollbar.slider_position)


	ENGINE.setTableCell = FUNCTION (table,row,column,content)
		// if it's not a structure, wrap a COMPONENT around it so we can set its position within the table cell
		if value_type(content) != "STRUCTURE" && content != UNDEFINED
			content = COMPONENT
				component = content
		table.cell[row][column] = content
		// use the default values for all undefined cell values
		if content != UNDEFINED
			LOCAL.can_expand = isExpandable(content)
			if content.x == UNDEFINED && table.cell_x != UNDEFINED && ( can_expand || hasVariable(content,"x") )
				if value_type(table.cell_x) == "CONSTANT"
					content.x = table.cell_x
				else
					content.x = table.cell_x[i]
			if content.y == UNDEFINED && table.cell_y != UNDEFINED && ( can_expand || hasVariable(content,"y") )
				if value_type(table.cell_y) == "CONSTANT"
					content.y = table.cell_y
				else
					content.y = table.cell_y[i]
			if content.v_align == UNDEFINED && table.cell_v_align != UNDEFINED && ( can_expand || hasVariable(content,"v_align") )
				if value_type(table.cell_v_align) == "CONSTANT"
					content.v_align = table.cell_v_align
				else
					content.v_align = table.cell_v_align[i]
			if content.h_align == UNDEFINED && table.cell_h_align != UNDEFINED && ( can_expand || hasVariable(content,"h_align") )
				if value_type(table.cell_h_align) == "CONSTANT"
					content.h_align = table.cell_h_align
				else
					content.h_align = table.cell_h_align[i]
				
				
	ENGINE.getTableCell = FUNCTION (table, row, column)
		return_value = table.cell[row][column]
		
				
	// swaps the rows at index a and b in the given table
	ENGINE.swapTableRows = FUNCTION (table, a, b)
		// first, swap the table rows themselves
		LOCAL.swap = table.component[a]
		table.component[a] = table.component[b]
		table.component[b] = swap
		// then fix the y coordinates
		LOCAL.i = table.cell_width.size-1
		while i >= 0
			table.component[a].component[i].y = a * table.cell_height
			table.component[b].component[i].y = b * table.cell_height
			i = i - 1
		