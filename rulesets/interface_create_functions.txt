english
	// creates a border with the given values
	ENGINE.createBorder = FUNCTION (bx, by, bwidth, bheight, bbackground_color, binverted, bcolor1, bcolor2)
		return_value = BORDER
			x        = &bx
			y        = &by
			width    = &bwidth
			height   = &bheight
			background_color = &bbackground_color
			inverted = binverted == true
			if &bcolor1 != UNDEFINED
				top_color = &bcolor1
			if &bcolor2 != UNDEFINED
				bottom_color = &bcolor2


	// the first argument must be a component or the text that is to be displayed in the popup. an optional second argument is the number of pixels used as padding everywhere. all the remaining arguments are treated as buttons and lined up at the bottom of the popup
	ENGINE.createPopup = FUNCTION (_text_or_component)
		if _text_or_component != UNDEFINED && value_type(_text_or_component) != "STRUCTURE"
			_text_or_component = TEXT
				text = _text_or_component
		return_value = COMPONENT
			x = CENTER
			y = CENTER
			LOCAL.i = 1
			LOCAL.padding = 10
			if value_type(argument[1]) == "INTEGER"
				i = 2
				padding = argument[1]
			LOCAL.w = padding     // this will be the padding on the right side of the last button
			LOCAL.h = 0
			while i < argument.length
				w = w + padding + pixelwidth(argument[i])
				h = max(h, pixelheight(argument[i]))
				i = i + 1
			h = h + 2 * padding + ( h > 0 && _text_or_component != UNDEFINED ? padding : 0 )    // the bracket adds the padding between the content and the question buttons
			width = min(pixelwidth(_text_or_content) + 2*padding, w) + 4 // the default border width



	ENGINE.createScrollbar = FUNCTION (_x, _y, _width, _height, _vertical, _slider, _slider_max, _up_left_arrow, _down_right_arrow, _slider_stepping, _slider_position)
		return_value = SCROLLBAR
			x = _x
			y = _y
			width = _width
			height = _height
			vertical = _vertical != false
			if _slider_stepping != UNDEFINED
				slider_stepping = _slider_stepping
			if _slider_max != UNDEFINED
				slider_max = _slider_max
			// add the slider and the optional arrow buttons
			if value_type(_slider) == "STRING"      // it's the name of an image. we need to turn it into a button
// !!
//				debug("a")
				LOCAL.b = _slider
//				debug("b")
// !! end
				_slider = BUTTON
					idle = b
//					idle = _slider
//				debug(_slider)
			if vertical
				_slider.x = CENTER
				_slider.y = 0   // the y position is adjusted every time the SCROLLBAR is drawn. this way it can adjust to mods with different sized buttons
			else
				_slider.x = 0
				_slider.y = CENTER  // the x position is adjusted every time the SCROLLBAR is drawn. this way it can adjust to mods with different sized buttons
			_slider.on_mouse_down = FUNCTION (mouse_x, mouse_y)
				SCROLLBAR.slider_dragging = vertical ? mouse_y : mouse_x
			component[0] = _slider
			if _up_left_arrow != UNDEFINED
				if value_type(_up_left_arrow) == "STRING"      // it's the name of an image. we need to turn it into a button
					_up_left_arrow = BUTTON
						idle = _up_left_arrow
				if vertical
					_up_left_arrow.x = CENTER
					_up_left_arrow.y = 0
				else
					_up_left_arrow.x = 0
					_up_left_arrow.y = CENTER
				_up_left_arrow.on_mouse_down = FUNCTION
					setSliderPosition(SCROLLBAR.this, slider_position - slider_stepping)
				component[1] = _up_left_arrow
			if _down_right_arrow != UNDEFINED
				if value_type(_down_right_arrow) == "STRING"      // it's the name of an image. we need to turn it into a button
					_down_right_arrow = BUTTON
						idle = _down_right_arrow
				if vertical
					_down_right_arrow.x = CENTER
					_down_right_arrow.y = BOTTOM
				else
					_down_right_arrow.x = RIGHT
					_down_right_arrow.y = CENTER
				_down_right_arrow.on_mouse_down = FUNCTION
					setSliderPosition(SCROLLBAR.this, slider_position + slider_stepping)
				component[2] = _down_right_arrow


	// image_array must contain 1-3 entries : [0] the slider, [1] the up/left arrow, [2] the down/right arrow
	ENGINE.createSimpleScrollbar = FUNCTION (boundingwidth, boundingheight, image_array, vertical)
		if vertical
			return_value = createScrollbar(RIGHT, 0, , boundingheight, true, image_array[0], 0, image_array[1], image_array[2])
		else
			return_value = createScrollbar(0, BOTTOM, boundingwidth, , false, image_array[0], 0, image_array[1], image_array[2])


	ENGINE.createTable = FUNCTION (pcolumns, pcell_height, pcell_width)
		return_value = TABLE
			columns = &pcolumns
			cell_height = &pcell_height
			if argument.size == 3
				cell_width = pcell_width
			else
				cell_width = ARRAY
				LOCAL.i = 2
				while i < argument.size
					width = width + argument[i]  // the width of the table
					cell_width[] = &argument[i]
					i = i + 1
				columns = cell_width.size


	// returns a new TEXT with the default settings as defined in the TEXT stored in TEXT_STYLE
	ENGINE.createText = FUNCTION (text, x, y, color, font, h_align, v_align, width, height)
		return_value = copy(@TEXT_STYLE)
		// for all settings which are not defined, the default settings will be used
		if text != UNDEFINED
			return_value.text = &text
		if x != UNDEFINED
			return_value.x = &x
		if y != UNDEFINED
			return_value.y = &y
		if color != UNDEFINED
			return_value.color = &color
		if font != UNDEFINED
			return_value.font = &font
		if h_align != UNDEFINED
			return_value.h_align = &h_align
		if v_align != UNDEFINED
			return_value.v_align = &v_align
		if width != UNDEFINED
			return_value.v_align = &width
		if height != UNDEFINED
			return_value.v_align = &height


	// returns a new TEXT with the default settings as defined in the TEXT stored in TEXT_STYLE
	ENGINE.createTextBold = FUNCTION (text, x, y, color, font)
		return_value = copy(@TEXT_STYLE_BOLD)
		// for all settings which are not defined, the default settings will be used
		if x != UNDEFINED
			return_value.x = &x
		if y != UNDEFINED
			return_value.y = &y
		if color != UNDEFINED
			return_value.color = &color
		if font != UNDEFINED
			return_value.font = &font
