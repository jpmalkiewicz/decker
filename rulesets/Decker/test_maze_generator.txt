english
	// create a 2 dimensional array with odd, not even, dimension sizes
	RULESET.maze = createSizedArray(77, 25, "wall")

	LOCAL.free_cells = ((maze.size-1)/2) * ((maze[0].size-1)/2)
	LOCAL.front_cell = createSizedArray(free_cells)

	// now lets start digging a maze into the area. front_cells contains the cells which may still have free neighbouring cells
	front_cell[0] = SET
		cx = maze.size/2+1 // the coordinates can be random but must be odd
		cy = maze[0].size/2+1
	LOCAL.front_cells = 0
	LOCAL.k = 0
	LOCAL.direction
	LOCAL.available_neighbours
	LOCAL.delta_x = createArray(-2,0,2,0)
	LOCAL.delta_y = createArray(0,-2,0,2)
	LOCAL.x
	LOCAL.y
	LOCAL.c
	while free_cells > 0
		maze[front_cell[front_cells].cx][front_cell[front_cells].cy] = "tunnel"
		front_cells++
		free_cells--
		// if the maze is complete, stop
		if free_cells == 0
			break
		// pick a random front cell
		available_neighbours = 0
		while available_neighbours == 0
			k = random(0,front_cells-1)
			// count the available neighbours of k, i.e. cells which are 2 cells away in x OR y direction and are still "wall" cells
			for direction = 3 downto 0
				x = front_cell[k].cx + delta_x[direction]
				y = front_cell[k].cy + delta_y[direction]
				if x > 0 && x < maze.size && y > 0 && y < maze[0].size && maze[x][y] == "wall"
					available_neighbours++
			// if k has no available neighbours or we're going to connect to its last available neighbour, remove it from the list of front cells
			c = front_cell[k]
			if available_neighbours <= 1
				front_cell[k] = front_cell[front_cells-1]
				front_cells--
		// connect one of the available cells to front_cell[k]
		while true
			direction = random(0,3)
			x = c.cx + delta_x[direction]
			y = c.cy + delta_y[direction]
			if x > 0 && x < maze.size && y > 0 && y < maze[0].size && maze[x][y] == "wall"
				front_cell[front_cells] = SET
					cx = LOCAL.x
					cy = LOCAL.y
				// make the connection between cell k and the new cell
				maze[x-delta_x[direction]/2][y-delta_y[direction]/2] = "tunnel"
				break

	// print the maze
	LOCAL.row
	for y = 0 to maze[0].size-1
		row = ""
		for x = 0 to maze.size-1
			row = row + ( maze[x][y] == "tunnel" ? " " : "#" )
		debug(row)
