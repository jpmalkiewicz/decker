english
	RULESET.compareProgramsPreset = FUNCTION (a, b)
		return_value = player.deck.program[b].type.id - player.deck.program[a].type.id


	RULESET.compareProgramsName = FUNCTION (a, b)
		return_value = player.deck.program[b].name < player.deck.program[a].name ? -1 : ( player.deck.program[b].name > player.deck.program[a].name ? 1 : 0 )


	RULESET.compareProgramsRating = FUNCTION (a, b)
		return_value = player.deck.program[a].rating - player.deck.program[b].rating


	RULESET.compareProgramsSize = FUNCTION (a, b)
		return_value = player.deck.program[a].size - player.deck.program[b].size


	RULESET.compareProgramsType = FUNCTION (a, b)
		return_value = player.deck.program[b].type.name < player.deck.program[a].type.name ? -1 : ( player.deck.program[b].type.name > player.deck.program[a].type.name ? 1 : 0 )


	RULESET.compareProgramsLoaded = FUNCTION (a, b)
		return_value = ( player.deck.program[b].state == INSTALLED ? 0 : 1 ) - ( player.deck.program[a].state == INSTALLED ? 0 : 1 )


	RULESET.compareProgramsDefault = FUNCTION (a, b)
		return_value = ( player.deck.program[b].type.default_category == UNDEFINED ? 2 : ( player.deck.program[b].state == DEFAULT ? 0 : 1 )) - ( player.deck.program[a].type.default_category == UNDEFINED ? 2 : ( player.deck.program[a].state == DEFAULT ? 0 : 1 ))


	RULESET.createDeck = FUNCTION (hardware_rating, program_rating)
		return_value = DECK
		if hardware_rating > 0
			return_value.cpu = hardware_rating
			return_value.coprocessor = hardware_rating
			return_value.attack = hardware_rating
			return_value.defense = hardware_rating
			return_value.stealth = hardware_rating
			return_value.analysis = hardware_rating
		if program_rating > 0
			return_value.program = ARRAY
				createProgram(ATTACK, program_rating)
				createProgram(PIERCING_ATTACK, program_rating+2)
				createProgram(SILENCE, program_rating)
				createProgram(SMOKE, program_rating)
				createProgram(ARMOR, program_rating)
				createProgram(MEDIC, program_rating)
				createProgram(HIDE, program_rating)
				createProgram(DECEIVE, program_rating)
				createProgram(ANALYZE, program_rating)
				createProgram(SCAN, program_rating)
				createProgram(EVALUATE, program_rating)
				createProgram(DECRYPT, program_rating)
			LOCAL.a = return_value.program.size - 1
			while a >= 0
				setProgramState(return_value, return_value.program[a], return_value.program[a].type.default_category != UNDEFINED ? DEFAULT : LOADED)
				a = a - 1
				

	RULESET.createHardware = FUNCTION (_type, _rating)
		// find the hardware type
		if value_type(_type) == "CONSTANT"
			LOCAL.i = 0
			LOCAL.c = UNDEFINED
			while i < HARDWARE_TYPES.size
				c = HARDWARE_TYPES[i].category
				if c[c.size-1] == _type
					_type = HARDWARE_TYPES[i]
					i = HARDWARE_TYPES.size  // to exit the while loop
				i = i + 1
		if _type.structure_type == "THING_TYPE"
			// create the piece of hardware
			return_value = THING
				type = _type
				rating = _rating
			// determine its default name
			if _rating >= 1
				LOCAL.basename = _type.default_name != UNDEFINED ? _type.default_name : _type.name
				if value_type(basename) == "ARRAY"
					if _rating < basename.size
						return_value.name = basename[_rating]
					else
						return_value.name = basename[basename.size-1] + " " + getRomanNumber(_rating - basename.size + 1)
				else
					if _rating == 1
						return_value.name = basename
					else
						return_value.name = basename + " " + getRomanNumber(_rating)


	RULESET.createProgram = FUNCTION (_type, _rating)
		// find the program type
		if value_type(_type) == "CONSTANT"
			LOCAL.i = 0
			LOCAL.c = UNDEFINED
			while i < PROGRAM_TYPES.size
				c = PROGRAM_TYPES[i].category
				if c[c.size-1] == _type
					_type = PROGRAM_TYPES[i]
					i = PROGRAM_TYPES.size  // to exit the while loop
				i = i + 1
		if _type.structure_type == "THING_TYPE"
			// create the program
			return_value = THING
				type = _type
				rating = _rating
				size = getThingSize(THING.this)
			// determine its default name
			if _rating >= 1
				if value_type(_type.default_name) == "ARRAY"
					if _rating < _type.default_name.size
						return_value.name = _type.default_name[_rating]
					else
						return_value.name = _type.default_name[_type.default_name.size-1] + " Mk "+getRomanNumber(_rating - _type.default_name.size + 1)


	// this function makes a mission available if it has a target system with a rating or it has a mission rating the rating is within +/-2 or +/-20% of the player's preferred mission rating
	RULESET.defaultMissionAvailable = FUNCTION
		if rating != UNDEFINED
			return_value = ( rating >= player.mission_base_rating-2 || rating >= player.mission_base_rating*4/5 ) && ( rating <= player.mission_base_rating+2 || rating <= player.mission_base_rating*6/5 )
		else if target_system.rating != UNDEFINED
			return_value = ( target_system.rating >= player.mission_base_rating-2 || target_system.rating >= player.mission_base_rating*4/5 ) && ( target_system.rating <= player.mission_base_rating+2 || target_system.rating <= player.mission_base_rating*6/5 )


	// calculates the mission rating for missions which have a target system
	RULESET.defaultMissionRating = FUNCTION
		if target_system.structure_type == "SYSTEM"
			special_condition = 0
			target_count = 0
			// there's either one goal or an array of goals
			if value_type(goal) != "ARRAY" &&( goal.structure_type == "NO_RED_ALARM" || goal.structure_type == "CREATE_BACKDOOR" || goal.structure_type == "CRASH_SYSTEM" || goal.structure_type == "TIME_RESTRICTION" )	
				special_condition = goal.structure_type == "TIME_RESTRICTION" ? 2 : 1
			if value_type(goal) == "ARRAY"
				target_count = goal.size
				i = 0
				while i < goal.size
					if goal[i].structure_type == "NO_RED_ALARM" || goal[i].structure_type == "CREATE_BACKDOOR" || goal[i].structure_type == "CRASH_SYSTEM" || goal[i].structure_type == "TIME_RESTRICTION"
						special_condition = special_condition + ( goal.structure_type == "TIME_RESTRICTION" ? 2 : 1 )
						target_count = target_count - 1
					i = i + 1
			return_value = target_system.rating + target_count / 2 + special_condition


	RULESET.displayInitializedScreen = FUNCTION (screen, remember_old_screen)
		displayScreen(screen, remember_old_screen)
		if value_type(screen.setup) == "FUNCTION"
			screen.setup()


	RULESET.getMaxLoad = FUNCTION (deck)
		return_value = 30 * ( deck.cpu + ( deck.cpu < deck.coprocessor ? deck.cpu : deck.coprocessor ) )


	// returns the roman number string for the given number. only works for numbers up to 4999. the format for the resulting numbers is intended for easy reading
	RULESET.getRomanNumber = FUNCTION (x)
		return_value = ""
		LOCAL.i = 0
		while x > 0
			while x >= ROMAN_NUMBER_VALUE[i]
				x = x - ROMAN_NUMBER_VALUE[i]
				return_value = return_value + ROMAN_NUMBER_LETTER[i]
			// now generate stuff like "XC" or "IV"
			if i + 2 < ROMAN_NUMBER_VALUE.size && substring(ROMAN_NUMBER_VALUE[i+2]+"", 0, 1) == "1" && ROMAN_NUMBER_VALUE[i]-ROMAN_NUMBER_VALUE[i+2] <= x
				x = x - (ROMAN_NUMBER_VALUE[i]-ROMAN_NUMBER_VALUE[i+2])
				return_value = return_value + ROMAN_NUMBER_LETTER[i+2] + ROMAN_NUMBER_LETTER[i]
			if i + 1 < ROMAN_NUMBER_VALUE.size && substring(ROMAN_NUMBER_VALUE[i+1]+"", 0, 1) == "1" && ROMAN_NUMBER_VALUE[i]-ROMAN_NUMBER_VALUE[i+1] <= x
				x = x - (ROMAN_NUMBER_VALUE[i]-ROMAN_NUMBER_VALUE[i+1])
				return_value = return_value + ROMAN_NUMBER_LETTER[i+1] + ROMAN_NUMBER_LETTER[i]
			i = i + 1


	// this function only makes sense for stuff that can be downloaded during a run or loaded onto a deck
	RULESET.getThingSize = FUNCTION (thing)
		LOCAL.type = thing.type
		if thing.source_code
// calculate the size of a source code here
		else
			if type.size_function != UNDEFINED
				return_value = type.size_function(thing)
			else
				return_value = type.complexity * thing.rating


	RULESET.getThingValue = FUNCTION (thing)
		LOCAL.type = thing.type
		if thing.source_code
// calculate the value of a source code here
		else
			if type.size_function != UNDEFINED
				return_value = type.size_function(thing)
			else if indexof(PROGRAM, type.category) >= 0 || indexof(CHIP, type.category) >= 0
				return_value = type.complexity * thing.rating * thing.rating * 25
				if indexof(CPU, type.category) >= 0
					return_value = return_value * 6 / 5        // CPUs are 20% more expensive than their rating suggests
			else // it's a piece of hardware. it's price is (base value * 2 ^ (rating-1))
				return_value = type.base_value * pow(2,thing.rating-1)



	// returns a ^ b. be must be a non-negative integer
	RULESET.pow = FUNCTION (a, b)
		return_value = 1
		while b > 0
			return_value = return_value * a
			b = b - 1


	RULESET.rollDice = FUNCTION (target_number)
		x = random(1,20)
		if x == 1
			return_value = -1         // 5% critical failure
		else if x == 20 && target_number > 20
			return_value = 1          // 5% automatic success (lowest possible positive outcome)
		else if x < target_number
			return_value = 0
		else
			return_value = 1 + (x-target_number)/4
			if return_value > 5
				return_value = 5
				
				
	RULESET.setProgramState = FUNCTION (deck, program, state)
		if state != program.state
			LOCAL.max_load = getMaxLoad(deck)
			if state != INSTALLED &&( program.state != LOADED && program.state != DEFAULT )
				if deck.used_memory + program.size <= max_load
					deck.used_memory = deck.used_memory + program.size
				else
					state = INSTALLED   // the program doesn't fit into the deck's memory
			if state == DEFAULT
				if deck.default_program[program.type.default_category] != UNDEFINED
					deck.default_program[program.type.default_category].state = LOADED   // the old default program is no longer the default program
				deck.default_program[program.type.default_category] = program
			if state == INSTALLED &&( program.state == LOADED || program.state == DEFAULT )
				deck.used_memory = deck.used_memory - program.size
				if program.state == DEFAULT
					deck.default_program[program.type.default_category] = UNDEFINED
			program.state = state
			deck.current_load = deck.used_memory <= max_load / 3 ? 0 : ( deck.used_memory <= max_load * 2 / 3 ? 1 : 2 )


	// comparator must return a value below zero if the compared rows are in the wrong order, 0 if they are identical, a positive value if they are in the correct order
	RULESET.sortTable = FUNCTION (table, comparator)
		LOCAL.a = 0
		LOCAL.b = 0
		LOCAL.c = table.component
		LOCAL.d = 0
		LOCAL.swap = false
		LOCAL.reverse = true
		// determine if the table is already in order
		while a+1 < c.size
			reverse = reverse && comparator(a, a+1) >= 0
			a = a + 1
		reverse = reverse ? -1 : 1
		// perform a bubblesort on the table rows
		a = 0
		while a+1 < c.size
			b = c.size - 1
			while b > a
				if reverse * comparator(a, b) < 0
					swapTableRows(table, a, b)
					// swap the programs on the deck
					swap = player.deck.program[a]
					player.deck.program[a] = player.deck.program[b]
					player.deck.program[b] = swap
				b = b - 1
			a = a + 1

	
	// sets the back button's image to whereever it currently leads back to
	RULESET.updateBackButton = FUNCTION (button)
		LOCAL.previous_screen = getPreviousScreen()
		if previous_screen == home_screen
			button.idle = "home/home"
		else
			button.idle = "home/matrix"


//*****************************************************************************************************************************************************
// action functions ***********************************************************************************************************************************
//*****************************************************************************************************************************************************


	RULESET.humanActionModifier = FUNCTION (human,stealth_action)        // if stealth_action is false it can be omitted
		return_value = DECK_LOAD_MODIFIER[human.deck] - human.deck.damage/8 - MIN(human.physical_damage,human.mental_damage)/4
		if human.current_node.smoke_level > 0
			return_value = return_value + ( stealth_action ? 4 : -4 )
		
	
	RULESET.humanRatingAttack = FUNCTION (human)
		return_value = humanActionModifier(human) + MIN(human.deck.attack,human.deck.cpu) + human.attack
		i = human.deck.program.size-1
		while i >= 0
			if human.deck.program[i].attack_modifier != UNDEFINED
				return_value = return_value + human.deck.program[i].attack_modifier


	RULESET.actionHumanAttackICE = FUNCTION (ice,program,target_number)
		successes = rollDice(target_number)
		if successes < 0
			print program.name + " program missed"
		else
			print program.name + " program does " + successes*successes*HEALTH_INCREMENT + "% damage to " + ice.name
			ice.damage = ice.damage + successes*successes
			if ice.damage >= LETHAL_DAMAGE
				actionCrashICE(human,ice)
		human.time = human.time + 1       // an action has been taken, advance the time

	
	RULESET.actionCrashICE = FUNCTION (ice)
		if ice.node == PLAYER.node
			print "<#success>" + ice.name + " has crashed"
			if PLAYER.current_target == ice
				PLAYER.current_target = UNDEFINED
			delete(ice.node.objects,ARRAY_INDEX(ice.node.objects,ice))
			// if the ice is a tapeworm it dies never to come back. otherwise it goes to the ice respawn list
			if ice.guards != UNDEFINED && ice.guards.structure_type == "FILE"
				delete(ice)
			else
				ice.node.area.destroyed_ice[] = ice
			


