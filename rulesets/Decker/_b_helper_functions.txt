english
	RULESET.arrayIndex = FUNCTION (array,entry)
		if array.size != UNDEFINED
			return_value = array.size - 1
			while return_value >= 0 && array[return_value] != entry
				return_value = return_value - 1
			if i == -1
				return_value = UNDEFINED

			
//	RULESET.createThing = FUNCTION(_thingtype, _rating)
//		return_value = THING
//			thingtype = _thingtype
//			rating = _rating == UNDEFINED ? 0 : _rating


	// this function makes a mission available if it has a target system with a rating or it has a mission rating the rating is within +/-2 or +/-20% of the player's preferred mission rating
	RULESET.defaultMissionAvailable = FUNCTION
		if rating != UNDEFINED
			return_value = ( rating >= player.mission_base_rating-2 || rating >= player.mission_base_rating*4/5 ) && ( rating <= player.mission_base_rating+2 || rating <= player.mission_base_rating*6/5 )
		else if target_system.rating != UNDEFINED
			return_value = ( target_system.rating >= player.mission_base_rating-2 || target_system.rating >= player.mission_base_rating*4/5 ) && ( target_system.rating <= player.mission_base_rating+2 || target_system.rating <= player.mission_base_rating*6/5 )


	// calculates the mission rating for missions which have a target system
	RULESET.defaultMissionRating = FUNCTION
		if target_system.structure_type == "SYSTEM"
			special_condition = 0
			target_count = 0
			// there's either one goal or an array of goals
			if goal.structure_type != "ARRAY" &&( goal.structure_type == "NO_RED_ALARM" || goal.structure_type == "CREATE_BACKDOOR" || goal.structure_type == "CRASH_SYSTEM" || goal.structure_type == "TIME_RESTRICTION" )	
				special_condition = goal.structure_type == "TIME_RESTRICTION" ? 2 : 1
			if goal.structure_type == "ARRAY"
				target_count = goal.size
				i = 0
				while i < goal.size
					if goal[i].structure_type == "NO_RED_ALARM" || goal[i].structure_type == "CREATE_BACKDOOR" || goal[i].structure_type == "CRASH_SYSTEM" || goal[i].structure_type == "TIME_RESTRICTION"
						special_condition = special_condition + ( goal.structure_type == "TIME_RESTRICTION" ? 2 : 1 )
						target_count = target_count - 1
					i = i + 1
			return_value = target_system.rating + target_count / 2 + special_condition

	
	// this function only makes sense for stuff that can be downloaded during a run or loaded onto a deck
	RULESET.getThingSize = FUNCTION (thing)
		LOCAL.type = thing.type
		if thing.source_code
// calculate the size of a source code here
		else
			if type.size_function != UNDEFINED
				return_value = type.size_function(thing)
			else
				return_value = type.complexity * thing.rating


	RULESET.getThingValue = FUNCTION (thing)
		LOCAL.type = thing.type
		if thing.source_code
// calculate the value of a source code here
		else
			if type.size_function != UNDEFINED
				return_value = type.size_function(thing)
			else if arrayIndex(type.category, PROGRAM) >= 0 || arrayIndex(type.category, CHIP) >= 0
				return_value = type.complexity * thing.rating * thing.rating * 25
				if arrayIndex(type.category, CPU) >= 0
					return_value = return_value * 6 / 5        // CPUs are 20% more expensive than their rating suggests
			else // it's a piece of hardware. it's price is (base value * 2 ^ (rating-1))
				return_value = type.base_value * pow(2,thing.rating)


	RULESET.initializeDeck = FUNCTION (deck,program_rating, hardware_rating)
		if hardware_rating > 0
			deck.cpu = harware_rating
			deck.coprocessor = harware_rating
			deck.attack = harware_rating
			deck.defense = harware_rating
			deck.stealth = harware_rating
			deck.analysis = harware_rating
		if program_rating > 0
			deck.program = ARRAY
				createThing(ATTACK_PROGRAM, program_rating)
				createThing(SILENCE_PROGRAM, program_rating)
				createThing(SMOKE_PROGRAM, program_rating)
				createThing(MEDIC_PROGRAM, program_rating)
				createThing(ARMOR_PROGRAM, program_rating)
				createThing(HIDE_PROGRAM, program_rating)
				createThing(DECEIVE_PROGRAM, program_rating)
				createThing(ANALYZE_PROGRAM, program_rating)
				createThing(SCAN_PROGRAM, program_rating)
				createThing(EVALUATE_PROGRAM, program_rating)
				createThing(DECRYPT_PROGRAM, program_rating)


	// returns a ^ b. be must be a non-negative integer
	RULESET.pow = FUNCTION (a, b)
		return_value = 1
		while b > 0
			return_value = return_value * a
			b = b - 1


	RULESET.rollDice = FUNCTION (target_number)
		x = random(1,20)
		if x == 1
			return_value = -1         // 5% critical failure
		else if x == 20 && target_number > 20
			return_value = 1          // 5% automatic success (smallest possible positive outcome)
		else if x < target_number
			return_value = 0
		else
			return_value = 1 + (x-target_number)/4
			if return_value > 5
				return_value = 5


	// sets the back button's image to whereever it currently leads back to
	RULESET.updateBackButton = FUNCTION (button)
		LOCAL.previous_screen = getPreviousScreen()
		if previous_screen == home_screen
			button.idle = "home/home"
		else
			button.idle = "home/matrix"


//*****************************************************************************************************************************************************
// action functions ***********************************************************************************************************************************
//*****************************************************************************************************************************************************


	RULESET.humanActionModifier = FUNCTION (human,stealth_action)        // if stealth_action is false it can be omitted
		return_value = DECK_LOAD_MODIFIER[human.deck] - human.deck.damage/8 - MIN(human.physical_damage,human.mental_damage)/4
		if human.current_node.smoke_level > 0
			return_value = return_value + ( stealth_action ? 4 : -4 )
		
	
	RULESET.humanRatingAttack = FUNCTION (human)
		return_value = humanActionModifier(human) + MIN(human.deck.attack,human.deck.cpu) + human.attack
		i = human.deck.program.size-1
		while i >= 0
			if human.deck.program[i].attack_modifier != UNDEFINED
				return_value = return_value + human.deck.program[i].attack_modifier


	RULESET.actionHumanAttackICE = FUNCTION (ice,program,target_number)
		successes = rollDice(target_number)
		if successes < 0
			print program.name + " program missed"
		else
			print program.name + " program does " + successes*successes*HEALTH_INCREMENT + "% damage to " + ice.name
			ice.damage = ice.damage + successes*successes
			if ice.damage >= LETHAL_DAMAGE
				actionCrashICE(human,ice)
		human.time = human.time + 1       // an action has been taken, advance the time

	
	RULESET.actionCrashICE = FUNCTION (ice)
		if ice.node == PLAYER.node
			print "<#success>" + ice.name + " has crashed"
			if PLAYER.current_target == ice
				PLAYER.current_target = UNDEFINED
			delete(ice.node.objects,ARRAY_INDEX(ice.node.objects,ice))
			// if the ice is a tapeworm it dies never to come back. otherwise it goes to the ice respawn list
			if ice.guards != UNDEFINED && ice.guards.structure_type == "FILE"
				delete(ice)
			else
				ice.node.area.destroyed_ice[] = ice
			


