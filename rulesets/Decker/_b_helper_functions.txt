english
	RULESET.arrayIndex = FUNCTION (array,entry)
		if array.size != UNDEFINED
			return_value = array.size - 1
			while return_value >= 0 && array[return_value] != entry
				return_value = return_value - 1
			if i == -1
				return_value = UNDEFINED

			
	RULESET.createDeck = FUNCTION (hardware_rating, program_rating)
		return_value = DECK
		if hardware_rating > 0
			return_value.cpu = hardware_rating
			return_value.coprocessor = hardware_rating
			return_value.attack = hardware_rating
			return_value.defense = hardware_rating
			return_value.stealth = hardware_rating
			return_value.analysis = hardware_rating
		if program_rating > 0
			return_value.program = ARRAY
				createProgram(ATTACK, program_rating)
				createProgram(SILENCE, program_rating)
				createProgram(SMOKE, program_rating)
				createProgram(ARMOR, program_rating)
				createProgram(MEDIC, program_rating)
				createProgram(HIDE, program_rating)
				createProgram(DECEIVE, program_rating)
				createProgram(ANALYZE, program_rating)
				createProgram(SCAN, program_rating)
				createProgram(EVALUATE, program_rating)
				createProgram(DECRYPT, program_rating)


	RULESET.createNameTableCell = FUNCTION (image, text)
		LOCAL.tx = pixelwidth(image)+1
		return_value = NAME_TABLE_CELL
			height = pixelheight(image)
			component[0] = image
			component[1] = createText(text, tx, CENTER, @TABLE_TEXT_COLOR)


	RULESET.createProgram = FUNCTION (_type, _rating, _status)
		// find the program type
		if value_type(_type) == "CONSTANT"
			LOCAL.i = 0
			LOCAL.c = UNDEFINED
			while i < PROGRAM_TYPES.size
				c = PROGRAM_TYPES[i].category
				if c[c.size-1] == _type
					_type = PROGRAM_TYPES[i]
					i = PROGRAM_TYPES.size  // to exit the while loop
				i = i + 1
		if _type.structure_type == "THING_TYPE"
			// create the program
			return_value = THING
				type = _type
				rating = _rating
				size = getThingSize(THING.this)
				if _status != UNDEFINED
					status = _status
			// determine its default name
			if _rating >= 1
				if _type.default_name.structure_type == "ARRAY"
					if _rating < _type.default_name.size
						return_value.name = _type.default_name[_rating]
					else
						return_value.name = _type.default_name[_type.default_name.size-1] + " Mk "+getRomanNumber(_rating - _type.default_name.size + 1)


	// this function makes a mission available if it has a target system with a rating or it has a mission rating the rating is within +/-2 or +/-20% of the player's preferred mission rating
	RULESET.defaultMissionAvailable = FUNCTION
		if rating != UNDEFINED
			return_value = ( rating >= player.mission_base_rating-2 || rating >= player.mission_base_rating*4/5 ) && ( rating <= player.mission_base_rating+2 || rating <= player.mission_base_rating*6/5 )
		else if target_system.rating != UNDEFINED
			return_value = ( target_system.rating >= player.mission_base_rating-2 || target_system.rating >= player.mission_base_rating*4/5 ) && ( target_system.rating <= player.mission_base_rating+2 || target_system.rating <= player.mission_base_rating*6/5 )


	// calculates the mission rating for missions which have a target system
	RULESET.defaultMissionRating = FUNCTION
		if target_system.structure_type == "SYSTEM"
			special_condition = 0
			target_count = 0
			// there's either one goal or an array of goals
			if goal.structure_type != "ARRAY" &&( goal.structure_type == "NO_RED_ALARM" || goal.structure_type == "CREATE_BACKDOOR" || goal.structure_type == "CRASH_SYSTEM" || goal.structure_type == "TIME_RESTRICTION" )	
				special_condition = goal.structure_type == "TIME_RESTRICTION" ? 2 : 1
			if goal.structure_type == "ARRAY"
				target_count = goal.size
				i = 0
				while i < goal.size
					if goal[i].structure_type == "NO_RED_ALARM" || goal[i].structure_type == "CREATE_BACKDOOR" || goal[i].structure_type == "CRASH_SYSTEM" || goal[i].structure_type == "TIME_RESTRICTION"
						special_condition = special_condition + ( goal.structure_type == "TIME_RESTRICTION" ? 2 : 1 )
						target_count = target_count - 1
					i = i + 1
			return_value = target_system.rating + target_count / 2 + special_condition


	RULESET.displayInitializedScreen = FUNCTION (screen, remember_old_screen)
		displayScreen(screen, remember_old_screen)
		if value_type(screen.setup) == "FUNCTION"
			screen.setup()


	// returns the roman number string for the given number. only works for numbers up to 4999. the format for the resulting numbers is intended for easy reading
	RULESET.getRomanNumber = FUNCTION (x)
		return_value = ""
		LOCAL.i = 0
		while x > 0
			while x >= ROMAN_NUMBER_VALUE[i]
				x = x - ROMAN_NUMBER_VALUE[i]
				return_value = return_value + ROMAN_NUMBER_LETTER[i]
			// now generate stuff like "XC" or "IV"
			if i + 2 < ROMAN_NUMBER_VALUE.size && substring(ROMAN_NUMBER_VALUE[i+2]+"", 0, 1) == "1" && ROMAN_NUMBER_VALUE[i]-ROMAN_NUMBER_VALUE[i+2] <= x
				x = x - (ROMAN_NUMBER_VALUE[i]-ROMAN_NUMBER_VALUE[i+2])
				return_value = return_value + ROMAN_NUMBER_LETTER[i+2] + ROMAN_NUMBER_LETTER[i]
			if i + 1 < ROMAN_NUMBER_VALUE.size && substring(ROMAN_NUMBER_VALUE[i+1]+"", 0, 1) == "1" && ROMAN_NUMBER_VALUE[i]-ROMAN_NUMBER_VALUE[i+1] <= x
				x = x - (ROMAN_NUMBER_VALUE[i]-ROMAN_NUMBER_VALUE[i+1])
				return_value = return_value + ROMAN_NUMBER_LETTER[i+1] + ROMAN_NUMBER_LETTER[i]
			i = i + 1


	// this function only makes sense for stuff that can be downloaded during a run or loaded onto a deck
	RULESET.getThingSize = FUNCTION (thing)
		LOCAL.type = thing.type
		if thing.source_code
// calculate the size of a source code here
		else
			if type.size_function != UNDEFINED
				return_value = type.size_function(thing)
			else
				return_value = type.complexity * thing.rating


	RULESET.getThingValue = FUNCTION (thing)
		LOCAL.type = thing.type
		if thing.source_code
// calculate the value of a source code here
		else
			if type.size_function != UNDEFINED
				return_value = type.size_function(thing)
			else if arrayIndex(type.category, PROGRAM) >= 0 || arrayIndex(type.category, CHIP) >= 0
				return_value = type.complexity * thing.rating * thing.rating * 25
				if arrayIndex(type.category, CPU) >= 0
					return_value = return_value * 6 / 5        // CPUs are 20% more expensive than their rating suggests
			else // it's a piece of hardware. it's price is (base value * 2 ^ (rating-1))
				return_value = type.base_value * pow(2,thing.rating)



	// returns a ^ b. be must be a non-negative integer
	RULESET.pow = FUNCTION (a, b)
		return_value = 1
		while b > 0
			return_value = return_value * a
			b = b - 1


	RULESET.rollDice = FUNCTION (target_number)
		x = random(1,20)
		if x == 1
			return_value = -1         // 5% critical failure
		else if x == 20 && target_number > 20
			return_value = 1          // 5% automatic success (smallest possible positive outcome)
		else if x < target_number
			return_value = 0
		else
			return_value = 1 + (x-target_number)/4
			if return_value > 5
				return_value = 5
				
				
	// comparator must return a value below zero if the compared rows are in the wrong order, 0 if they are identical, a positive value if they are in the correct order
	RULESET.sortTable = FUNCTION (table, comparator)
		LOCAL.a = 0
		LOCAL.b = 0
		LOCAL.c = table.component
		LOCAL.d = 0
		LOCAL.swap = false
		LOCAL.reverse = true
		// determine if the table is already in order
		while a+1 < c.size
			reverse = reverse && comparator(a, a+1) >= 0
			a = a + 1
		reverse = reverse ? -1 : 1
		// perform a bubblesort on the table rows
		a = 0
		while a+1 < c.size
			b = c.size - 1
			while b > a
				if reverse * comparator(a, b) < 0
					swapTableRows(table, a, b)
					// swap the programs on the deck
					swap = player.deck.program[a]
					player.deck.program[a] = player.deck.program[b]
					player.deck.program[b] = swap
				b = b - 1
			a = a + 1
		debug(player.deck.program[0].name)
		debug(c[0].component[1])
	
	RULESET.compareProgramsDefault = FUNCTION (a, b)
		return_value = player.deck.program[b].type.id - player.deck.program[a].type.id
			

	// sets the back button's image to whereever it currently leads back to
	RULESET.updateBackButton = FUNCTION (button)
		LOCAL.previous_screen = getPreviousScreen()
		if previous_screen == home_screen
			button.idle = "home/home"
		else
			button.idle = "home/matrix"


	RULESET.wrapImage = FUNCTION (image_name)
		return_value = COLLECTION
			object = ARRAY
				image_name


//*****************************************************************************************************************************************************
// action functions ***********************************************************************************************************************************
//*****************************************************************************************************************************************************


	RULESET.humanActionModifier = FUNCTION (human,stealth_action)        // if stealth_action is false it can be omitted
		return_value = DECK_LOAD_MODIFIER[human.deck] - human.deck.damage/8 - MIN(human.physical_damage,human.mental_damage)/4
		if human.current_node.smoke_level > 0
			return_value = return_value + ( stealth_action ? 4 : -4 )
		
	
	RULESET.humanRatingAttack = FUNCTION (human)
		return_value = humanActionModifier(human) + MIN(human.deck.attack,human.deck.cpu) + human.attack
		i = human.deck.program.size-1
		while i >= 0
			if human.deck.program[i].attack_modifier != UNDEFINED
				return_value = return_value + human.deck.program[i].attack_modifier


	RULESET.actionHumanAttackICE = FUNCTION (ice,program,target_number)
		successes = rollDice(target_number)
		if successes < 0
			print program.name + " program missed"
		else
			print program.name + " program does " + successes*successes*HEALTH_INCREMENT + "% damage to " + ice.name
			ice.damage = ice.damage + successes*successes
			if ice.damage >= LETHAL_DAMAGE
				actionCrashICE(human,ice)
		human.time = human.time + 1       // an action has been taken, advance the time

	
	RULESET.actionCrashICE = FUNCTION (ice)
		if ice.node == PLAYER.node
			print "<#success>" + ice.name + " has crashed"
			if PLAYER.current_target == ice
				PLAYER.current_target = UNDEFINED
			delete(ice.node.objects,ARRAY_INDEX(ice.node.objects,ice))
			// if the ice is a tapeworm it dies never to come back. otherwise it goes to the ice respawn list
			if ice.guards != UNDEFINED && ice.guards.structure_type == "FILE"
				delete(ice)
			else
				ice.node.area.destroyed_ice[] = ice
			


