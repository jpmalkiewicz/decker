english
	// this is just a helper function. it gets called when the actionSTATE() function needs to be called
	RULESET.iceAct = FUNCTION (ice)
		LOCAL.a = getStructureMember(ice.type, "action"+ice.current_action)
		if value_type(a) == "FUNCTION"
			a(ice)




	// called for an ice when it's turn to act has arrived
	RULESET.iceAction = FUNCTION (ice)
		if ice.type.updateState(ice)
			if !(ice.confused > 0)
				iceAct(ice)
			else
				// trace ice ay stop tracing
				if player.tracing_ice == ice && random(0,3) == 0
					player.tracing_ice = UNDEFINED
					print getName(ice) + " cancels its trace!"
				// choose a random action
				LOCAL.a = random(0,4)
				if a == 0
					// attack self
					LOCAL.b = rollDie(10)    // = (random(1,20)-10+3)/4
					if b > 0
						b = b*b
						ice.damage = ice.damage + b
						print getName(ice) + " does " + b*HEALTH_INCREMENT +"% damage to itself"
						if ice.damage >= LETHAL_DAMAGE
							crashICE(ice)
				if a == 1
					// attack player
					LOCAL.b = ice.type.type
					if ice.node == player.node &&( b == ATTACK || b == TRACE || b == PROBE )
						ice.current_action = ATTACKING
						ice.hostile = true
						iceAct(ice)
					else
						iceSoundAlarm(ice,RED)
						a = 2
				if a == 2
					// attack another ice, but only if we are an ATTACK ice
					if ice.type.type != ATTACK
						a = random(3,4)
					else
						// count the other ice in the node
						LOCAL.b = 0
						LOCAL.o = ice.node.objects
						for i = o.size-1 downto 0
							if o[i].structure_type == "ICE" && o[i] != ice
								b++
						if b == 0
							a = random(3,4)
						else
							b = random(1,b)
							for i = o.size-1 downto 0
								if o[i].structure_type == "ICE" && o[i] != ice
									b--
									if b == 0
										o = o[i]
										// attack this ice
										b = rollDie(10 - getAttackRating(ice, false) + getDefenseRating(o, false))
										if b > 0
											b = b*b
											o.damage = o.damage + b
											print getName(ice) + " attacks " + getName(o) + " for " + b*HEALTH_INCREMENT + " damage!"
											if o.damage >= LETHAL_DAMAGE
												crashIce(o)
										break
				if a == 3
					LOCAL.b = ice.type.type
					if b == ATTACK || b == TRACE || b == PROBE
						if player.querying_ice == ice
							player.querying_ice = UNDEFINED
						iceWander(ice)
				// a == 4 means the ice doesn't do anything




	// this is an ATTACK or TRACE ice that is guarding the node where the player has last been sighted and recognized as hostile. this ice is currently not hostile
	RULESET.iceAction_ATTACK_GUARDING = FUNCTION (ice)
		if ice.node == player.node && iceNoticesPlayer(ice)
			iceQueryPlayer(ice)




	// this is a GUARD_ACCESS, GUARD_EXIT or GUARD_FILE ice in its normal state
	RULESET.iceAction_GUARD_GUARDING = FUNCTION (ice)
		if ice.hostile
			iceSoundAlarm(ice,RED)




	// returns true if the ice can act, false otherwise
	RULESET.iceActionUpdateState = FUNCTION (ice)
		return_value = true
		if ice.slowed > 0
			ice.slowed--
			if ice.slowed == 0
				print getName(ice) + " is no longer slowed"
			else if ice.slowed%2 == 1
				return_value = false     // skip odd turns. ice always starts with an even value so it skips directly after getting slowed
		if return_value && ice.virus > 0
				ice.virus--
				if ice.virus == 0
					print getName(ice) + " is no longer slowed"
				else
					ice.damage++
					if ice.damage >= LETHAL_DAMAGE
						crashICE(ice)
						return_value = false
		if return_value && ice.confused > 0
			ice.confused--
			if ice.confused == 0
				print getName(ice) + " is no longer confused"
		if return_value && ice.weakened > 0
			ice.weakened--
			if ice.weakened == 0
				print getName(ice) + " is no longer weakened"




	RULESET.iceNoticesPlayer = FUNCTION (ice)
		LOCAL.a = player.deck.default_program[DEFAULT_HIDE]
		return_value = a == UNDEFINED || value_type(a.type.passive_effect) != "FUNCTION" || !a.type.passive_effect(player, a, ice)




	RULESET.iceQueryPlayer = FUNCTION (ice)
		if ice.rating <= player.highest_deceived_ice
			return_value = false
		else
			return_value = true
			// if there is currently no querying ice or its rating is lower than ours, it's time for us to query
			if !( player.querying_ice.rating >= ice.rating )
				if player.deck.decoys.size > 0
					iceSoundAlarm(ice,RED)
			else
				LOCAL.a = player.querying_ice
				if a != UNDEFINED
					a.state = substring(a.type.type, 0, 6) == "GUARD_" ? GUARDING : FOLLOWING
				player.querying_ice = ice
				ice.current_action = QUERYING1
				player.current_target = ice
				print getName(ice) + " is querying you"




	RULESET.iceSoundAlarm = FUNCTION (ice, alarm_level)
		if ice.node.silenced > 0
// ***************
// ***************
// ***************
// ***************




	RULESET.iceWander = FUNCTION (ice)
		with ice
			current_action = ROAMING
				LOCAL.count = 0
				for i = 3 downto 0
					if node.connection[i] != UNDEFINED
						count++
				// if there is at least one exit, move
				if count > 0
					// if there is only one exit, move there even if we just came from there
					if count == 1
						previous_node = UNDEFINED
					i = random(0,3)
					while node.connection[i] == UNDEFINED || node.connection[i] == previous_node
						i = random(0,3)
					moveObject(ice, node.connection[i])
					debug("moving wandering ice "+getName(ice)+"  ("+previous_node.x+","+previous_node.y+") -> ("+node.x+","+node.y+")")



// ***************************************************************************************
// ***************************************************************************************
// ***************************************************************************************
// ***************************************************************************************



	// called when the ice is currently following the player and trying to query him/her
	RULESET.iceFollow = FUNCTION (ice)
		ice.current_action = FOLLOWING
		// if this node is not smoked and the player is in a neighbouring node, move there
		if ice.node != player.node && ice.node.smoke_level == 0
			LOCAL.n = ice.node
			for i = 3 downto 0
				if n.connection[i] != UNDEFINED && n.connection[i] == player.node
					moveObject(ice, i)
					n = true // this will tell the next if command that the ice has already taken its action this turn
					break
		// if the player cannot be found or s/he has passed a query, roam
		if !n &&( ice.node != player.node || !iceQuery(ice) )
			iceRoam(ice)


// ***************
	RULESET.iceGoingHome = FUNCTION (ice)
		if ice.hostile

		// if the player is currently in this node and we're looking for intruders, query him/her
		if !ice.hostile && !ice.bypassed && player.node == ice.node && ice.node.area.system.alert_level == RED &&( ice.type.type == ATTACK || ice.type.type == TRACE )


	RULESET.iceNoticesPlayer = FUNCTION (ice)
		return_value = true
		LOCAL.p = player.deck.default_program[DEFAULT_HIDE]
		if p != UNDEFINED
			LOCAL.target_number = 10 + 2*player.system.rating + getAnalysisRating(ice) - getStealthRating(player) - p.rating
// ************* player.decoy_level isn't defined yet
			// If decoys are in use, it is far more difficult to hide from ice
			if player.decoy_level > 0
				target_number = target_number + 4
			LOCAL.successes = rollDie(target_number)
			if successess > 0
// play the sound of the hide program p
				print getName(ice) + " fails to notice you."
			return_value = successess <= 0


	RULESET.iceRoam = FUNCTION (ice)
		with ice
			current_action = ROAMING
			if node != player.node || !iceNoticesPlayer(ice) || !iceQuery(ice)
				iceWander(ice)


// ***************
	RULESET.iceSoundAlarm = FUNCTION (ice)


	// returns the current sensor rating for an ice. the value can be negative
	RULESET.iceRatingSensor = FUNCTION (ice, include_analyzed=true)
		if ice.structure_type == "ICE"
			return_value = ice.rating - ice.damage/4                     // the rating goes down by one for every 4 damage the ice has taken
			if ice.weaken > 0
				return_value = return_value - 4
			if include_analyzed && ice.analyzed > 0
				return_value = return_value - ice.analyzed                                // substract the maximum number of successes achieved in a single analyze attempt on this ice
			if ice.white  &&  player.current_system.status != UNDEFINED  &&  player.current_system.status != GREEN
				return_value = return_value + 2                                           // white ice gets a +2 sensor modifier during yellow and red alert
