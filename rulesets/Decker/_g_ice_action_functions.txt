english
	// called for an ice when it's turn to act has arrived
	RULESET.iceAction = FUNCTION (ice)
		if ice.type.updateState(ice)
			if !(ice.confused > 0)
				LOCAL.a = getStructureMember(ice.type, "action"+ice.current_action)
				if value_type(a) == "FUNCTION"
					a(ice)
			else
				if player.tracing_ice == ice && random(0,3) == 0
					player.tracing_ice = UNDEFINED
					player.trace_countdown = UNDEFINED
					print getName(ice) + " cancels its trace!"
				LOCAL.a = random(0,4)
				if a == 0
					LOCAL.b = rollDie(10)    // = (random(1,20)-10+3)/4
					if b > 0
						b = b*b
						ice.damage = ice.damage + b
						print getName(ice) + " does " + b*HEALTH_INCREMENT +"% damage to itself"
						if ice.damage >= LETHAL_DAMAGE
							crashICE(ice)
				if a == 1
// **********



	// returns true if the ice can act, false otherwise
	RULESET.iceActionUpdateState = FUNCTION (ice)
		return_value = true
		if ice.slowed > 0
			ice.slowed--
			if ice.slowed == 0
				print getName(ice) + " is no longer slowed"
			else if ice.slowed%2 == 1
				return_value = false     // skip odd turns. ice always starts with an even value so it skips directly after getting slowed
		if return_value && ice.virus > 0
				ice.virus--
				if ice.virus == 0
					print getName(ice) + " is no longer slowed"
				else
					ice.damage++
					if ice.damage >= LETHAL_DAMAGE
						crashICE(ice)
						return_value = false
		if return_value && ice.confused > 0
			ice.confused--
			if ice.confused == 0
				print getName(ice) + " is no longer confused"
		if return_value && ice.weakened > 0
			ice.weakened--
			if ice.weakened == 0
				print getName(ice) + " is no longer weakened"



	// called when the ice is currently following the player and trying to query him/her
	RULESET.iceFollow = FUNCTION (ice)
		ice.current_action = FOLLOWING
		// if this node is not smoked and the player is in a neighbouring node, move there
		if ice.node != player.node && ice.node.smoke_level == 0
			LOCAL.n = ice.node
			for i = 3 downto 0
				if n.connection[i] != UNDEFINED && n.connection[i] == player.node
					moveObject(ice, i)
					n = true // this will tell the next if command that the ice has already taken its action this turn
					break
		// if the player cannot be found or s/he has passed a query, roam
		if !n &&( ice.node != player.node || !iceQuery(ice) )
			iceRoam(ice)


// ***************
	RULESET.iceGoingHome = FUNCTION (ice)
		if ice.hostile

		// if the player is currently in this node and we're looking for intruders, query him/her
		if !ice.hostile && !ice.bypassed && player.node == ice.node && ice.node.area.system.alert_level == RED &&( ice.type.type == ATTACK || ice.type.type == TRACE )


	RULESET.iceNoticesPlayer = FUNCTION (ice)
		return_value = true
		LOCAL.p = player.deck.default_program[DEFAULT_HIDE]
		if p != UNDEFINED
			LOCAL.target_number = 10 + 2*player.system.rating + getAnalysisRating(ice) - getStealthRating(player) - p.rating
// ************* player.decoy_level isn't defined yet
			// If decoys are in use, it is far more difficult to hide from ice
			if player.decoy_level > 0
				target_number = target_number + 4
			LOCAL.successes = rollDie(target_number)
			if successess > 0
// play the sound of the hide program p
				print getName(ice) + " fails to notice you."
			return_value = successess <= 0


// ***************
	RULESET.iceQuery = FUNCTION (ice)


	RULESET.iceRoam = FUNCTION (ice)
		with ice
			current_action = ROAMING
			if node != player.node || !iceNoticesPlayer(ice) || !iceQuery(ice)
				LOCAL.count = 0
				for i = 3 downto 0
					if node.connection[i] != UNDEFINED
						count++
				// if there is at least one exit, move
				if count > 0
					// if there is only one exit, move there even if we just came from there
					if count == 1
						previous_node = UNDEFINED
					i = random(0,3)
					while node.connection[i] == UNDEFINED || node.connection[i] == previous_node
						i = random(0,3)
					previous_node = node
					moveObject(ice, i)
					debug("moving roaming ice "+type.name[rating]+"  ("+previous_node.x+","+previous_node.y+") -> ("+node.x+","+node.y+")")


// ***************
	RULESET.iceSoundAlarm = FUNCTION (ice)


	// returns the current sensor rating for an ice. the value can be negative
	RULESET.iceRatingSensor = FUNCTION (ice, include_analyzed=true)
		if ice.structure_type == "ICE"
			return_value = ice.rating - ice.damage/4                     // the rating goes down by one for every 4 damage the ice has taken
			if ice.weaken > 0
				return_value = return_value - 4
			if include_analyzed && ice.analyzed > 0
				return_value = return_value - ice.analyzed                                // substract the maximum number of successes achieved in a single analyze attempt on this ice
			if ice.white  &&  player.current_system.status != UNDEFINED  &&  player.current_system.status != GREEN
				return_value = return_value + 2                                           // white ice gets a +2 sensor modifier during yellow and red alert
