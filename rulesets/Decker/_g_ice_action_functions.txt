english
	// this is just a helper function. it gets called when the actionSTATE() function needs to be called
	RULESET.iceAct = FUNCTION (ice)
		LOCAL.a = getStructureMember(ice.type, "action"+ice.current_action)
		if value_type(a) == "FUNCTION"
			a(ice)
		else
			// something has seriously gone wrong, the ice has a "current_action" it has no function for. let it go home
			iceChooseNewAction(ice)




	// this is an ATTACK ice that is actively guarding its home node during a red alert
	RULESET.iceAction_GUARDING_ATTACK = FUNCTION (ice)
		if ice.node == player.node && iceNoticesPlayer(ice)
			iceQueryPlayer(ice)




	RULESET.iceAction_SEARCHING = FUNCTION (ice)
		if ice.node != player.node || ice.rating <= player.highest_deceived_ice || !iceNoticesPlayer(ice) || !iceQueryPlayer(ice)
			// response ice has a 50% chance of moving towards the node where an alarm has last been sounded
			if ice.response_ice && ice.node.area.system.alert_level == RED && ice.node.response_direction != UNDEFINED && random(0,1) == 0
// need to define response_direction
				moveObject(ice, indexof(ice.node.response_direction, ice.node.connection))
			else
				iceWander(ice)




	RULESET.iceChooseAction = FUNCTION (ice, act = true)
		// is the ice fighting the player?
		if ice.node == player.node && player.hostile
			ice.current_action = ATTACKING
		else if ice.current_action == ATTACKING || ice.current_action == QUERYING
			// if we are still in the same node as the player, continue fighting or querying. otherwise stop that and try to find the player
			if act && ice.node != player.node
				// if the player fled from a querying ice, sound a yellow alert
				if ice.current_action == QUERYING
					iceSoundAlarm(ice, YELLOW)
				// try to follow the player
				if ice.type.attributes.follows && !(ice.node.smoked > 0)
					LOCAL.a = indexof(player.node, ice.node.connection)
					if a >= 0
						act = false
						moveObject(ice, a)
						if ice.current_action == ATTACKING
							iceSoundAlarm(ice)
				// if the player has vanished or this ice cannot follow, choose something new to do
// there's a special case where the ice was hostile and follows the player by chance. in that case it should stay hostile
				if act
					ice.current_action = UNDEFINED
		//***********************************
		// attacking and querying ice has been handled. now comes attack ice at its home node and response ice, during a red alert
		//***********************************
		if ice.current_action != ATTACKING && ice.current_action != QUERYING
			// is there a red alert?
			if ice.node.area.system.alert_level != RED
				ice.current_action = UNDEFINED
			else
				if ice.response_ice
					// if we are a reponse ice and an intruder has just been detected or we are not already in SEARCHING mode, go to the response target node
					if ice.node != ice.node.area.response_ice_target &&( ice.current_action != SEARCHING || ice.node.area.alert_time >= player.current_time - 1 )
						ice.current_action = RESPONDING
					else
						ice.current_action = SEARCHING
				// non-response attack ice actively guards its home node during a red alert
				else if ice.node == ice.home_node && ice.type.type == ATTACK
					ice.current_action = GUARDING
				else
					ice.current_action = UNDEFINED
			//***********************************
			// special red alert behaviour has been handled. now do normal behavior
			//***********************************
			if ice.current_action == UNDEFINED
				// respawned response ice and ice with SEARCHING as its initial action (e.g. PROBE ice) will search the system
				if ( ice.response_ice && ice.respawned )||( ice.type.initial_action == SEARCHING && ice.type.initial_state == ACTIVE )
					ice.current_action = SEARCHING
				// all other ice will go home
				else if ice.node != ice.home_node
					ice.current_action = GOING_HOME
				else
					// the ice already is at home. it returns to its initial action
					ice.current_action = ice.type.initial_action
					// we may need to remove the ice from the list of active ice
					if ice.type.initial_state != ACTIVE
						delete(ice.node.area.active_ice, ice)
						// if the ice is now passively waiting again, add it to that list
						if ice.type.initial_state == PASSIVE
							ice.node.area.waiting_ice[] = ice






	RULESET.iceSoundAlarm = FUNCTION (ice, alert_level = RED)
// **********************************************************************
// DO NOT ignore alarm attempts which occur in the node where the player is if the payer already has the hostile tag and the response node is the player node




	RULESET.iceWander = FUNCTION (ice)
		with ice
			LOCAL.count = 0
			for i = 3 downto 0
				if node.connection[i] != UNDEFINED
					count++
			// if there is at least one exit, move
			if count > 0
				// if there is only one exit, move there even if we just came from there
				if count == 1
					previous_node = UNDEFINED
				i = random(0,3)
				while node.connection[i] == UNDEFINED || node.connection[i] == previous_node
					i = random(0,3)
				moveObject(ice, i)
				debug("moving wandering ice "+getName(ice)+"  ("+previous_node.x+","+previous_node.y+") -> ("+node.x+","+node.y+")")
