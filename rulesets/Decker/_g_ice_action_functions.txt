english
	// this is just a helper function. it gets called when the actionSTATE() function needs to be called
	RULESET.iceAct = FUNCTION (ice)
		LOCAL.a = getStructureMember(ice.type, "action"+ice.current_action)
		if value_type(a) == "FUNCTION"
			a(ice)
		else
			// something has seriously gone wrong, the ice has a "current_action" it has no function for. let it go home
			iceChooseNewAction(ice)




	// this is an ATTACK ice that is actively guarding its home node during a red alert
	RULESET.iceAction_GUARDING_ATTACK = FUNCTION (ice)
		if ice.node == player.node && iceNoticesPlayer(ice)
			iceQueryPlayer(ice)




	RULESET.iceAction_SEARCHING = FUNCTION (ice)
		if ice.node != player.node || ice.rating <= player.highest_deceived_ice || !iceNoticesPlayer(ice) || !iceQueryPlayer(ice)
			// response ice has a 50% chance of moving towards the node where an alarm has last been sounded
			if ice.response_ice && ice.node.area.system.alert_level == RED && ice.node.response_direction != UNDEFINED && random(0,1) == 0
// need to define response_direction
				moveObject(ice, indexof(ice.node.response_direction, ice.node.connection))
			else
				iceWander(ice)




	RULESET.iceChooseAction = FUNCTION (ice, act = true)
		// is the ice fighting the player?
		if ice.node == player.node && player.hostile
			ice.current_action = ATTACKING
		else if ice.current_action == ATTACKING || ice.current_action == QUERYING
			// if we are still in the same node as the player, continue fighting or querying. otherwise stop that and try to find the player
			if act && ice.node != player.node
				// if the player fled from a querying ice, sound a yellow alert
				if ice.current_action == QUERYING
					iceSoundAlarm(ice, YELLOW)
				// try to follow the player
				if ice.type.attributes.follows && !(ice.node.smoked > 0)
					LOCAL.a = indexof(player.node, ice.node.connection)
					if a >= 0
						act = false
						moveObject(ice, a)
						if ice.current_action == ATTACKING
							iceSoundAlarm(ice)
				// if the player has vanished or this ice cannot follow, choose something new to do
				if act
					if ice.current_action == ATTACKING
						ice.last_hostile_turn = player.current_turn
					ice.current_action = UNDEFINED
		//***********************************
		// attacking and querying ice has been handled. now comes attack ice at its home node and response ice, during a red alert
		//***********************************
		if ice.current_action != ATTACKING && ice.current_action != QUERYING
			// is there a red alert?
			if ice.node.area.system.alert_level != RED
				ice.current_action = UNDEFINED
			else
				if ice.response_ice
					// if we are a reponse ice and an intruder has just been detected or we are not already in SEARCHING mode, go to the response target node
					if ice.node != ice.node.area.response_ice_target &&( ice.current_action != SEARCHING || ice.node.area.alert_time >= player.current_turn - 1 )
						ice.current_action = RESPONDING
					else
						ice.current_action = SEARCHING
				// non-response attack ice actively guards its home node during a red alert
				else if ice.node == ice.home_node && ice.type.type == ATTACK
					ice.current_action = GUARDING
				else
					ice.current_action = UNDEFINED
			//***********************************
			// special red alert behaviour has been handled. now do all normal behavior
			//***********************************
			if ice.current_action == UNDEFINED
				// respawned response ice and ice with SEARCHING as its initial action (e.g. probe ice) will search the system
				if ( ice.response_ice && ice.respawned )|| ice.type.initial_action == SEARCHING
					ice.current_action = SEARCHING
				// all other ice will go home
				else if ice.node != ice.home_node
					ice.current_action = GOING_HOME
				else
					// the ice already is at home. it returns to its initial action
					ice.current_action = ice.type.initial_action
					// we may need to remove the ice from the list of active ice
					if ice.type.initial_state != ACTIVE
						delete(ice.node.area.active_ice, ice)
						// if the ice is now passively waiting again, add it to that list
						if ice.type.initial_state == PASSIVE
							ice.node.area.waiting_ice[] = ice




	RULESET.iceSoundAlarm = FUNCTION (ice, alert_level = RED)
		// is there only a yellow alert?
		if alert_level == YELLOW && ice.node.area.system.alert_level == GREEN && !(ice.node.silenced>0)
			ice.node.area.system.alert_level = YELLOW
			print "<#orange>" + getName(ice) + (ice.node==player.node ? "" : " in node "+ice.node.name) + " signals a yellow alert."
		else
			// if the
			if !ice.node.hostile
				ice.node.hostile = true

		if al
// wrong. ignores whether player is in the node
		if ice.node.silenced > 0
			iceMakeHostile()
		else if ice.node.area.system.alert_level == RED
			ice.node.area.response_ice_target = ice.node
// mark the path for response ice
			iceMakeHostile()
		else
			if alert_level == YELLOW && ice.node.area.system.alert_level == GREEN
// (play yellow alert sound)
				print "<#orange>" + getName(ice) + (ice.node==player.node ? "" : " in node "+ice.node.name) + " signals a yellow alert."
				ice.node.area.system.alert_level = YELLOW
			else
// (play red alert sound)
				print "<#red>" + getName(ice) + (ice.node==player.node ? "" : " in node "+ice.node.name) + " signals a red alert!"
//*********************************************************
				debug ("iceSoundAlarm needs to make a note about the red alert in the current mission's status")
//*********************************************************
				ice.node.area.system.alert_level = RED
				ice.node.area.response_ice_target = ice.node
				// activate all waiting ice. it moves towards the alarm in the ice's area, it switches from INACTIVE to GUARDING in all other areas
				LOCAL.area = ice.node.area
				LOCAL.a = area.system.area
				for j = a.size-1 downto 0
					// let all the active response_ice react to the alarm
					LOCAL.w = a[j].active_ice
					for i = w.size-1 downto 0
						if w[i].response_ice
							w[i].type.reactToAlarm(w[i], area)
					// move all the waiting ice to the active_ice list
					LOCAL.w = a[j].waiting_ice
					a[j].active_ice = a[j].active_ice + w
					a[j].waiting_ice = ARRAY
					// let all the formerly waiting ice react to the alarm
					for i = w.size-1 downto 0
						w[i].type.reactToAlarm(w[i], area)
//*********************************************************
// if player node, attach the alarm sounded pic to the ice
//*********************************************************




	RULESET.iceWander = FUNCTION (ice)
		with ice
			LOCAL.count = 0
			for i = 3 downto 0
				if node.connection[i] != UNDEFINED
					count++
			// if there is at least one exit, move
			if count > 0
				// if there is only one exit, move there even if we just came from there
				if count == 1
					previous_node = UNDEFINED
				i = random(0,3)
				while node.connection[i] == UNDEFINED || node.connection[i] == previous_node
					i = random(0,3)
				moveObject(ice, i)
				debug("moving wandering ice "+getName(ice)+"  ("+previous_node.x+","+previous_node.y+") -> ("+node.x+","+node.y+")")
