english
	RULESET.generateNodeIce = FUNCTION (node, node_rating, cluster)
		with node
			LOCAL.a
			LOCAL.r
			// add guard_exit ice
			for i = 3 downto 0
				if connection[i] && cluster[x][y] != cluster[x+DELTA_X[i]][y+DELTA_Y[i]]
					objects[] = generateIce(GUARD_EXIT, node_rating, node, i)
			// add the normal ice. junctions don't have any ice beyond the GUARD_EXIT ice generated above
			if type != JUNCTION
				// determine how much extra ice there should be
				r = random(0,3) + (type==CPU||type==COP||type==COP_SECURITY?2:0) + (type==SPU||type==PORTAL_IN||type==PORTAL_OUT?1:0)
				if r == 3
					r = 2
				else if r > 3
					r = 3
				else if r == 0 &&( type==IO_ICE || IO_EXTERNAL_ALERT )&& random(0,40) < node_rating
					r = 1
				// no more than one ice in the system entry node, to make things easier
				if r > 1 && type == PORTAL_OUT &&( target.structure_type != "NODE" || target.area.system != area.system )
					r = 1
				// make the ice
				for i = r-1 downto 0
					if i == 0
						// the first ice is a PROBE, GUARD_ACCESS, or response ATTACK ice
						if type == COP
							objects[] = generateIce(PROBE, node_rating, node)
						else if type == PORTAL_OUT &&( target.structure_type != "NODE" || target.area.system != area.system )
							// a GUARD_EXIT ice is usually pointless in a node that leads out of the system, so we use an ATTACK ice instead
							objects[] = generateIce(ATTACK, node_rating, node, true)
						else
							// all other ice types get a GUARD_ACCESS ice
							objects[] = generateIce(GUARD_ACCESS, node_rating, node)
					else if i == 1
						// the second ice in a node is attack or trace
						// if this node is a COP, the ice will also respond to system alerts
						if node_rating > 2 && random(1,4) == 1
							objects[] = generateIce(TRACE, node_rating, node, node.type==COP)
						else
							objects[] = generateIce(ATTACK, node_rating, node, node.type==COP)
					else
						// all remaining ice will be attack
						// if this node is a COP, the ice will also respond to system alerts
						objects[] = generateIce(ATTACK, node_rating, node, node.type==COP)
				if type == DATASTORE
					// add GUARD_FILE ice to the datastore files
					for i = file.size-1 downto 0
						a = file[i].type
						r = random(1,20)
						if a == USELESS
							if r == 1
								objects[] = generateIce(GUARD_FILE, node_rating, node, file[i])
						else if a == VALUABLE
							if r <= 4
								objects[] = generateIce(GUARD_FILE, node_rating, node, file[i])
						else if a == QUEST
							if r <= 6
								objects[] = generateIce(GUARD_FILE, node_rating, node, file[i])
						else if a == CLUE
							if r <= 15
								objects[] = generateIce(GUARD_FILE, node_rating, node, file[i])
						else if a == PASSWORD
							objects[] = generateIce(GUARD_FILE, node_rating, node, file[i])





	RULESET.pickIceType = FUNCTION (_type, _rating)
		LOCAL.t = ARRAY
		// find all the types with the correct general type and which have a version for the supplied _rating
		for i = ICE_TYPES.size-1 downto 0
			if ICE_TYPES[i].type == _type && ICE_TYPES[i].min_rating <= _rating
				t[] = ICE_TYPES[i]
		// if there is onley one type, we're done
		if t.size == 1
			return_value = t[0]
		else
			// otherwise determine the probability of each type
			LOCAL.p = createSizedArray(t.size)
			LOCAL.r = 0
			for i = t.size-1 downto 0
				p[i] = value_type(t[i].probability) != "FUNCTION" ? t[i].probability : t[i].probability(_rating)
				if p[i] < 0
					p[i] = 0
				r = r + p[i]
			// pick one of the available types
			r = random(0,r-1)
			LOCAL.i = 0
			while r >= p[i]
				r = r - p[i]
				i = i + 1
			return_value = t[i]


	RULESET.generateIce = FUNCTION (_type, _rating, _node, data)
		// there is a 10% [5%] chance that ice from with rating 2 [4] and above gets a +1 [+2] rating bonus
		LOCAL.r = random(1,20)
		if r <= 2 && _rating > 1
			_rating++
		else if r <= 3 && _rating > 3
			_rating = _rating + 2
		// ice in a CPU, SPU, and (if it's not a GUARD_EXIT ice) COP_SECURITY gets a +1 to its rating
		if _node.type == CPU || node.type == SPU ||( node.type == COP_SECURITY && _type != GUARD_EXIT )
			_rating++
		// guard_exit ice gets a rating boost if it leads to a CPU or SPU
		if _type == GUARD_EXIT && _node.type != CPU && node.type != SPU && data >= 0 && data <= 3 && _node.area.map != UNDEFINED
			r = _node.area.map[_node.x+DELTA_X[data]][_node.y+DELTA_Y[data]]
			if r.type == CPU || r.type == SPU
				_rating++
		// create the ice
		return_value = ICE
			type = pickIceType(_type, _rating)
			rating = _rating
			node = _node
		if _type == GUARD_EXIT
			return_value.guarded_direction = data
		else if _type == GUARD_FILE
			return_value.guarded_file = data
		else if data
			return_value.response_ice = true
		placeObject(return_value, _node)


	RULESET.notOccupied = FUNCTION (node, x, y)
		return_value = true
		LOCAL.o = node.objects
		for i = o.size-1 downto 0
			if o[i].x == x && o[i].y == y
				return_value = false
				break


	RULESET.placeObject = FUNCTION (object, node)
		LOCAL.x
		LOCAL.y
		LOCAL.node_map = getStructureMember(BLOCKED_NODE_REGIONS, toLowerCase(getNodeTypeCategory(node.type)))
		if object.structure_type == "ICE"
			if object.type.type == GUARD_EXIT
				x = 4 + DELTA_X[object.guarded_direction] * 4
				y = 4 + DELTA_Y[object.guarded_direction] * 4
			else if object.type.type == GUARD_ACCESS
				x = 4
				y = 4
		if x == UNDEFINED
			x = random(0,8)
			y = random(0,8)
			while !node_map[x][y]
				x = random(0,8)
				y = random(0,8)
		// now that we have a point to start from, find the nearest free spot
		if !node_map[x][y] && notOccupied(node, x, y)
			object.x = x
			object.y = y
		else
			LOCAL.radius = 0
			LOCAL.x2
			LOCAL.y2
			LOCAL.blocked = true
			while blocked && radius <= 8
				// search the next outer ring of cells
				radius++
				for i = -radius+1 to radius
					x2 = x + i
					y2 = y - radius
					if x2 >= 0 && x2 <= 8 && y2 >= 0 && !node_map[x2][y2] && notOccupied(node, x2, y2)
						object.x = x2
						object.y = y2
						blocked = false
						break
					x2 = x - i
					y2 = y + radius
					if x2 >= 0 && x2 <= 8 && y2 <= 8 && !node_map[x2][y2] && notOccupied(node, x2, y2)
						object.x = x2
						object.y = y2
						blocked = false
						break
					x2 = x + radius
					y2 = y + i
					if x2 >= 0 && x2 <= 8 && y2 >= 0 && !node_map[x2][y2] && notOccupied(node, x2, y2)
						object.x = x2
						object.y = y2
						blocked = false
						break
					x2 = x - radius
					y2 = y - i
					if x2 >= 0 && x2 <= 8 && y2 >= 0 && !node_map[x2][y2] && notOccupied(node, x2, y2)
						object.x = x2
						object.y = y2
						blocked = false
						break
			// if there is no free location in the node, just put the object at a random exit (this should never happen)
			if radius > 8
				LOCAL.direction = random(0,3)
				object.x = 4 + DELTA_X[direction] * 4
				object.y = 4 + DELTA_Y[direction] * 4
