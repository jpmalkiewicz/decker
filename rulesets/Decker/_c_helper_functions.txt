english
	RULESET.compareNumbers = FUNCTION (row_a, row_b, table, column)
		LOCAL.a = table.cell[row_a][column].text
		LOCAL.b = table.cell[row_b][column].text
		if ( value_type(a) == "INTEGER" || value_type(a) == "REAL" )&&( value_type(b) == "INTEGER" || value_type(b) == "REAL" )
			return_value = a - b
		else  // at least one of them is not a number
			if a == UNDEFINED || a == ""
				if b != UNDEFINED && b != ""
					return_value = -1
				else
					return_value = b < a ? -1 : ( b > a ? 1 : 0 )
			else
				if b == UNDEFINED || b == ""
					return_value = 1
				else
					return_value = b < a ? -1 : ( b > a ? 1 : 0 )


	RULESET.compareNumbersInverted = FUNCTION (row_a, row_b, table, column)
		LOCAL.a = table.cell[row_a][column].text
		LOCAL.b = table.cell[row_b][column].text
		if ( value_type(a) == "INTEGER" || value_type(a) == "REAL" )&&( value_type(b) == "INTEGER" || value_type(b) == "REAL" )
			return_value = b - a
		else  // at least one of them is not a number
			if a == UNDEFINED || a == ""
				if b != UNDEFINED && b != ""
					return_value = -1
				else
					return_value = b < a ? -1 : ( b > a ? 1 : 0 )
			else
				if b == UNDEFINED || b == ""
					return_value = 1
				else
					return_value = b < a ? -1 : ( b > a ? 1 : 0 )


	RULESET.compareProgramsPreset = FUNCTION (a, b)
		return_value = player.deck.program[b].type.id - player.deck.program[a].type.id


	RULESET.compareShopItemsPreset = FUNCTION (a, b)
		return_value = player.shop_inventory[b].type.id - player.shop_inventory[a].type.id


	RULESET.compareProgramsLoaded = FUNCTION (a, b)
		return_value = ( player.deck.program[b].state == INSTALLED ? 0 : 1 ) - ( player.deck.program[a].state == INSTALLED ? 0 : 1 )


	RULESET.compareProgramsDefault = FUNCTION (a, b)
		return_value = ( player.deck.program[b].type.default_category == UNDEFINED ? 2 : ( player.deck.program[b].state == DEFAULT ? 0 : 1 )) - ( player.deck.program[a].type.default_category == UNDEFINED ? 2 : ( player.deck.program[a].state == DEFAULT ? 0 : 1 ))


	RULESET.compareText = FUNCTION (row_a, row_b, table, column)
		LOCAL.a = table.cell[row_a][column].text
		LOCAL.b = table.cell[row_b][column].text
		return_value = b < a ? -1 : ( b > a ? 1 : 0 )


	RULESET.createChip = FUNCTION (_type, _rating)
		// find the chip type
		if value_type(_type) == "CONSTANT"
			LOCAL.c
			for i = 0 to CHIP_TYPES.size-1
				c = CHIP_TYPES[i].category
				if c[c.size-1] == _type
					_type = CHIP_TYPES[i]
					break
		if _type.structure_type == "THING_TYPE"
			// create the chip
			return_value = THING
				type = _type
				rating = _rating
			// determine its default name
			if _rating >= 1
				LOCAL.basename = _type.default_name != UNDEFINED ? _type.default_name : _type.name
				if value_type(basename) == "ARRAY"
					if _rating < basename.size
						return_value.name = basename[_rating]
					else
						return_value.name = basename[basename.size-1] + " " + getRomanNumber(_rating - basename.size + 1)
				else
					if _rating == 1
						return_value.name = basename
					else
						return_value.name = basename + " " + getRomanNumber(_rating)


	RULESET.createDeck = FUNCTION (hardware_rating, program_rating)
		return_value = DECK
		if hardware_rating > 0
			return_value.cpu = hardware_rating
			return_value.coprocessor = hardware_rating
			return_value.attack = hardware_rating
			return_value.defense = hardware_rating
			return_value.stealth = hardware_rating
			return_value.analysis = hardware_rating
		if program_rating > 0
			return_value.program = ARRAY
				createProgram(ATTACK, program_rating)
				createProgram(PIERCING_ATTACK, program_rating+2)
				createProgram(SILENCE, program_rating)
				createProgram(SMOKE, program_rating)
				createProgram(ARMOR, program_rating)
				createProgram(MEDIC, program_rating)
				createProgram(HIDE, program_rating)
				createProgram(DECEIVE, program_rating)
				createProgram(ANALYZE, program_rating)
				createProgram(SCAN, program_rating)
				createProgram(EVALUATE, program_rating)
				createProgram(DECRYPT, program_rating)
			for a = return_value.program.size - 1 to 0 step -1
				setProgramState(return_value, return_value.program[a], return_value.program[a].type.default_category != UNDEFINED ? DEFAULT : LOADED)


	RULESET.createHardware = FUNCTION (_type, _rating)
		// find the hardware type
		if value_type(_type) == "CONSTANT"
			LOCAL.c
			for i = 0 to HARDWARE_TYPES.size-1
				c = HARDWARE_TYPES[i].category
				if c[c.size-1] == _type
					_type = HARDWARE_TYPES[i]
					break
		if _type.structure_type == "THING_TYPE"
			// create the piece of hardware
			return_value = THING
				type = _type
				rating = _rating
			// determine its default name
			if _rating >= 1
				LOCAL.basename = _type.default_name != UNDEFINED ? _type.default_name : _type.name
				if value_type(basename) == "ARRAY"
					if _rating < basename.size
						return_value.name = basename[_rating]
					else
						return_value.name = basename[basename.size-1] + " " + getRomanNumber(_rating - basename.size + 1)
				else
					if _rating == 1
						return_value.name = basename
					else
						return_value.name = basename + " " + getRomanNumber(_rating)


	RULESET.createProgram = FUNCTION (_type, _rating)
		// find the program type
		if value_type(_type) == "CONSTANT"
			LOCAL.c
			for i = 0 to PROGRAM_TYPES.size-1
				c = PROGRAM_TYPES[i].category
				if c[c.size-1] == _type
					_type = PROGRAM_TYPES[i]
					break
		if _type.structure_type == "THING_TYPE"
			// create the program
			return_value = THING
				type = _type
				rating = _rating
				size = getThingSize(THING.this)
			// determine its default name
			if _rating >= 1
				if value_type(_type.default_name) == "ARRAY"
					if _rating < _type.default_name.size
						return_value.name = _type.default_name[_rating]
					else
						return_value.name = _type.default_name[_type.default_name.size-1] + " Mk "+getRomanNumber(_rating - _type.default_name.size + 1)


	// this function makes a mission available if it has a target system with a rating or it has a mission rating the rating is within +/-2 or +/-20% of the player's preferred mission rating
	RULESET.defaultMissionAvailable = FUNCTION
		if rating != UNDEFINED
			return_value = ( rating >= player.mission_base_rating-2 || rating >= player.mission_base_rating*4/5 ) && ( rating <= player.mission_base_rating+2 || rating <= player.mission_base_rating*6/5 )
		else if target_system.rating != UNDEFINED
			return_value = ( target_system.rating >= player.mission_base_rating-2 || target_system.rating >= player.mission_base_rating*4/5 ) && ( target_system.rating <= player.mission_base_rating+2 || target_system.rating <= player.mission_base_rating*6/5 )


	// calculates the mission rating for missions which have a target system
	RULESET.defaultMissionRating = FUNCTION
		if target_system.structure_type == "SYSTEM"
			LOCAL.special_condition = 0
			LOCAL.target_count = 0
			// there's either one goal or an array of goals
			if value_type(goal) != "ARRAY" &&( goal.structure_type == "NO_RED_ALARM" || goal.structure_type == "CREATE_BACKDOOR" || goal.structure_type == "CRASH_SYSTEM" || goal.structure_type == "TIME_RESTRICTION" )
				special_condition = goal.structure_type == "TIME_RESTRICTION" ? 2 : 1
			if value_type(goal) == "ARRAY"
				target_count = goal.size
				for i = goal.size-1 to 0 step -1
					if goal[i].structure_type == "NO_RED_ALARM" || goal[i].structure_type == "CREATE_BACKDOOR" || goal[i].structure_type == "CRASH_SYSTEM" || goal[i].structure_type == "TIME_RESTRICTION"
						special_condition = special_condition + ( goal.structure_type == "TIME_RESTRICTION" ? 2 : 1 )
						target_count = target_count - 1
			return_value = target_system.rating + target_count / 2 + special_condition


	RULESET.displayInitializedScreen = FUNCTION (screen, remember_old_screen)
		displayScreen(screen, remember_old_screen)
		if value_type(screen.setup) == "FUNCTION"
			screen.setup()


	RULESET.getMaxLoad = FUNCTION (deck)
		return_value = 30 * ( deck.cpu + ( deck.cpu < deck.coprocessor ? deck.cpu : deck.coprocessor ) )


	// returns the roman number string for the given number. only works for numbers up to 4999. the format for the resulting numbers is intended for easy reading
	RULESET.getRomanNumber = FUNCTION (x)
		return_value = ""
		for (i = 0; x > 0; i++)
			while x >= ROMAN_NUMBER_VALUE[i]
				x = x - ROMAN_NUMBER_VALUE[i]
				return_value = return_value + ROMAN_NUMBER_LETTER[i]
			// now generate stuff like "XC" or "IV"
			if i + 2 < ROMAN_NUMBER_VALUE.size && substring(ROMAN_NUMBER_VALUE[i+2]+"", 0, 1) == "1" && ROMAN_NUMBER_VALUE[i]-ROMAN_NUMBER_VALUE[i+2] <= x
				x = x - (ROMAN_NUMBER_VALUE[i]-ROMAN_NUMBER_VALUE[i+2])
				return_value = return_value + ROMAN_NUMBER_LETTER[i+2] + ROMAN_NUMBER_LETTER[i]
			if i + 1 < ROMAN_NUMBER_VALUE.size && substring(ROMAN_NUMBER_VALUE[i+1]+"", 0, 1) == "1" && ROMAN_NUMBER_VALUE[i]-ROMAN_NUMBER_VALUE[i+1] <= x
				x = x - (ROMAN_NUMBER_VALUE[i]-ROMAN_NUMBER_VALUE[i+1])
				return_value = return_value + ROMAN_NUMBER_LETTER[i+1] + ROMAN_NUMBER_LETTER[i]


	// this function only makes sense for stuff that can be downloaded during a run or loaded onto a deck
	RULESET.getThingSize = FUNCTION (thing)
		LOCAL.type = thing.type
		if thing.source_code
// calculate the size of a source code here
			debug("getThingSize(<source_code>) RETURNS UNDEFINED")
		else
			if type.size_function != UNDEFINED
				return_value = type.size_function(thing)
			else
				return_value = type.complexity * thing.rating


	RULESET.getThingValue = FUNCTION (thing)
		LOCAL.type = thing.type
		if thing.source_code
// calculate the value of a source code here
			debug("getThingValue(<source_code>) RETURNS UNDEFINED")
		else
			if type.size_function != UNDEFINED
				return_value = type.size_function(thing)
			else if indexof(PROGRAM, type.category) >= 0 || indexof(CHIP, type.category) >= 0
				return_value = type.complexity * thing.rating * thing.rating * 25
				if indexof(CPU, type.category) >= 0
					return_value = return_value * 6 / 5        // CPUs are 20% more expensive than their rating suggests
			else // it's a piece of hardware. it's price is (base value * 2 ^ (rating-1))
				return_value = type.base_value * pow(2,thing.rating-1)



	// returns a ^ b. be must be a non-negative integer
	RULESET.pow = FUNCTION (a, b)
		return_value = 1
		for ( ; b > 0; b--)
			return_value = return_value * a


	RULESET.rollDice = FUNCTION (target_number)
		x = random(1,20)
		if x == 1
			return_value = -1         // 5% critical failure
		else if x == 20 && target_number > 20
			return_value = 1          // 5% automatic success (lowest possible positive outcome)
		else if x < target_number
			return_value = 0
		else
			return_value = 1 + (x-target_number)/4
			if return_value > 5
				return_value = 5


	RULESET.setProgramState = FUNCTION (deck, program, state)
		if state != program.state
			LOCAL.max_load = getMaxLoad(deck)
			if state != INSTALLED &&( program.state != LOADED && program.state != DEFAULT )
				if deck.used_memory + program.size <= max_load
					deck.used_memory = deck.used_memory + program.size
				else
					state = INSTALLED   // the program doesn't fit into the deck's memory
			if state == DEFAULT
				if deck.default_program[program.type.default_category] != UNDEFINED
					deck.default_program[program.type.default_category].state = LOADED   // the old default program is no longer the default program
				deck.default_program[program.type.default_category] = program
			if state == INSTALLED &&( program.state == LOADED || program.state == DEFAULT )
				deck.used_memory = deck.used_memory - program.size
				if program.state == DEFAULT
					deck.default_program[program.type.default_category] = UNDEFINED
			program.state = state
			deck.current_load = deck.used_memory <= max_load / 3 ? 0 : ( deck.used_memory <= max_load * 2 / 3 ? 1 : 2 )


	// comparator must return a value below zero if the compared rows are in the wrong order, 0 if they are identical, a positive value if they are in the correct order
	RULESET.sortTable = FUNCTION (table, comparator, column, displayed_array)
		LOCAL.c = table.cell
		LOCAL.swap
		LOCAL.reverse = true
		LOCAL.selected_row
		if table.selected_row >= 0 && table.selected_row < table.rows
			selected_row = table.cell[table.selected_row]
		// determine if the table is already in order
		for a = c.size-2 to 0 step -1
			reverse = reverse && comparator(a, a+1, table, column) >= 0
		reverse = reverse ? -1 : 1
		// perform a bubblesort on the table rows
		for a = c.size-2 to 0 step -1
			for b = 0 to a
				if reverse * comparator(b, b+1, table, column) < 0
					swap = c[b+1]
					c[b+1] = c[b]
					c[b] = swap
					// swap the corresponding entries in the displayed array, if there is one
					if displayed_array != UNDEFINED
						swap = displayed_array[b+1]
						displayed_array[b+1] = displayed_array[b]
						displayed_array[b] = swap
		// move the row selection
		if selected_row != UNDEFINED
			for a = table.rows-1 to 0 step -1
				if c[a] == selected_row
					table.selected_row = a
					break


	// sets the back button's image to whereever it currently leads back to
	RULESET.updateBackButton = FUNCTION (button)
		LOCAL.previous_screen = getPreviousScreen()
		if previous_screen == home_screen
			button.idle = "home/home"
		else
			button.idle = "home/matrix"


//*****************************************************************************************************************************************************
// action functions ***********************************************************************************************************************************
//*****************************************************************************************************************************************************


	RULESET.humanActionModifier = FUNCTION (human,stealth_action)        // if stealth_action is false it can be omitted
		return_value = DECK_LOAD_MODIFIER[human.deck] - human.deck.damage/8 - min(human.physical_damage,human.mental_damage)/4
		if human.current_node.smoke_level > 0
			return_value = return_value + ( stealth_action ? 4 : -4 )


	RULESET.humanRatingAttack = FUNCTION (human)
		return_value = humanActionModifier(human) + min(human.deck.attack,human.deck.cpu) + human.attack
		for (i = human.deck.program.size-1; i>=0; i--)
			if human.deck.program[i].attack_modifier != UNDEFINED
				return_value = return_value + human.deck.program[i].attack_modifier


	RULESET.actionHumanAttackICE = FUNCTION (ice,program,target_number)
		successes = rollDice(target_number)
		if successes < 0
			print program.name + " program missed"
		else
			print program.name + " program does " + successes*successes*HEALTH_INCREMENT + "% damage to " + ice.name
			ice.damage = ice.damage + successes*successes
			if ice.damage >= LETHAL_DAMAGE
				actionCrashICE(human,ice)
		human.time = human.time + 1       // an action has been taken, advance the time
		debug("actionHumanAttackICE() : advance the mission time")


	RULESET.actionCrashICE = FUNCTION (ice)
		if ice.node == PLAYER.node
			print "<#success>" + ice.name + " has crashed"
			if PLAYER.current_target == ice
				PLAYER.current_target = UNDEFINED
			delete(ice.node.objects,ARRAY_INDEX(ice.node.objects,ice))
			// if the ice is a tapeworm it dies never to come back. otherwise it goes to the ice respawn list
			if ice.guards != UNDEFINED && ice.guards.structure_type == "FILE"
				delete(ice)
			else
				ice.node.area.destroyed_ice[] = ice



