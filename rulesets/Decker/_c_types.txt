english
// ****************************************************************************************************************************************************
// global functions ***********************************************************************************************************************************
// ****************************************************************************************************************************************************


	// this function makes a mission available if it has a target system with a rating or it has a mission rating the rating is within +/-2 or +/-20% of the player's preferred mission rating
	RULESET.DEFAULT_MISSION_AVAILABLE = FUNCTION
		if rating != UNDEFINED
			return_value = ( rating >= player.mission_base_rating-2 || rating >= player.mission_base_rating*4/5 ) && ( rating <= player.mission_base_rating+2 || rating <= player.mission_base_rating*6/5 )
		else if target_system.rating != UNDEFINED
			return_value = ( target_system.rating >= player.mission_base_rating-2 || target_system.rating >= player.mission_base_rating*4/5 ) && ( target_system.rating <= player.mission_base_rating+2 || target_system.rating <= player.mission_base_rating*6/5 )

	// calculates the mission rating for missions which have a target system
	RULESET.DEFAULT_MISSION_RATING = FUNCTION
		if target_system.structure_type == "SYSTEM"
			special_condition = 0
			target_count = 0
			// there's either one goal or an array of goals
			if goal.structure_type != "ARRAY" &&( goal.structure_type == "NO_RED_ALARM" || goal.structure_type == "CREATE_BACKDOOR" || goal.structure_type == "CRASH_SYSTEM" || goal.structure_type == "TIME_RESTRICTION" )	
				special_condition = goal.structure_type == "TIME_RESTRICTION" ? 2 : 1
			if goal.structure_type == "ARRAY"
				target_count = goal.size
				i = 0
				while i < goal.size
					if goal[i].structure_type == "NO_RED_ALARM" || goal[i].structure_type == "CREATE_BACKDOOR" || goal[i].structure_type == "CRASH_SYSTEM" || goal[i].structure_type == "TIME_RESTRICTION"
						special_condition = special_condition + ( goal.structure_type == "TIME_RESTRICTION" ? 2 : 1 )
						target_count = target_count - 1
					i = i + 1
			return_value = target_system.rating + target_count / 2 + special_condition

	// returns the name of the image to be displayed, deducing it from the state "0" image. e.g. DEDUCE_IMAGE_NAME("my_button0", "1") will return "my_button1" if an image "my_button1.*" exists, otherwise it returns "my_button0"
	RULESET.DEDUCE_IMAGE_NAME = FUNCTION (base_name, new_suffix)
		return_value = base_name
		// make sure it's not a structure. if it's a structure, just return it
		if base_name.structure_type == UNDEFINED
			base_name = base_name + ""    // turns it into a string
			LOCAL.k = indexof("0", base_name, false)
			return_value = base_name
			// check whether there's a "0" suffix, possibly followed by a supported image file type extension
			if k != UNDEFINED
				if k == size(base_name)-1
					// the "0" sits at the end of the string
					if image_exists(substring(base_name,0,k) + new_suffix)
						return_value = substring(base_name,0,k) + new_suffix
				else
					// check whether there's a file type extension after the "0", otherwise the "0" is not a suffix and we'll just return the base_name
					LOCAL.file_type = to_lower_case(base_name.substring(k+1))
					if file_type == ".gif" || file_type == ".png" || file_type == ".bmp" ||file_type == ".jpg" || file_type == ".jpeg"
						if image_exists(substring(base_name,0,k) + new_suffix)
							return_value = substring(base_name,0,k) + new_suffix
							
	
// ****************************************************************************************************************************************************
// structure types ************************************************************************************************************************************
// ****************************************************************************************************************************************************


	STRUCTURE_TYPE
		COLLECTION
			expandable = true
		
		GLOBAL
			expandable = true
	
// mission goal types *********************************************************************************************************************************

		CRASH_SYSTEM
			status = INCOMPLETE
			incomplete
			completed		

		CREATE_BACKDOOR            extends CRASH_SYSTEM

		DOWNLOAD_FILE              extends CRASH_SYSTEM
			target
	
		DOWNLOAD_AND_ERASE_FILE    extends DOWNLOAD_FILE
	
		EDIT_FILE                  extends DOWNLOAD_FILE

		ERASE_FILE                 extends DOWNLOAD_FILE

		MANIPULATE_IO              extends DOWNLOAD_FILE
	
		RUN_PROGRAM                extends DOWNLOAD_FILE
			program
			execution_time
			remaining_execution_time
		
		NO_RED_ALARM
			status = COMPLETED
			completed
			failed

		TIME_RESTRICTION
			start_time
			end_time
			status = COMPLETED
			completed
			incomplete
			failed

// system related types *******************************************************************************************************************************

		SYSTEM_TYPE
			name
			file
			deactivate_io_target
			activate_io_target
			sabotage_io_target
			useless_file

		SYSTEM
			name
			rating
			type
			status = GREEN
			area
			initializer = FUNCTION
				area = ARRAY
			
		AREA
			name
			system
			destroyed_ice
			ice_entry_node
			
		NODE
			name
			area
			smoke_level
			objects       // ice and humans
		
		FILE
			name
			type
			description
			size
			value = 0
			
		ICE
			expandable = true
			name
			rating
			damage = 0
			node
			// hardened
			// phasing
			// trace_time
			// trace_target
			
// miscellaneous types ********************************************************************************************************************************

		THING_TYPE
			type_name
			category               // an array listing all the categories this thing type belongs to
			value                  // a function to calculate the value of things of this type
			size                   // a function to calculate the size of things of this type
			default_name           // an array : default_name[x] is the default name of a thing of this type and item_rating x
			effect                 // a function that gets executed when things of this type are used
			sorting_priority       //integer. determines the default order of items in displayed lists (shop, a deck's loaded programs, ...)
		
		THING
			expandable = true
			name
			type           // a THING_TYPE object
			rating
			size
			status         // price if it's in the shop, status if it's a program in the deck (INSTALLED, LOADED, RUNNING)
			
		DECK
			model = "(custom built)"
			damage = 0
			current_load = 0  // 0 = light, 1 = medium, 2 = high
			cpu = 1
			coprocessor = 1
			attack = 1
			defense = 1
			stealth = 1
			analysis = 1
			program
			intializer = FUNCTION
				program = ARRAY
			
		MISSION
			expandable = true
			variables_see_each_other = true
			available = @DEFAULT_MISSION_AVAILABLE
			status = INCOMPLETE
			can_be_started = true
			title
			description
			payment
			target_system
			filename                // name of the script this mission comes from
			goal
			rating = @DEFAULT_MISSION_RATING
			deadline = 5
			can_be_dropped = true
			age = 0
			failed_attempts = 0
			reload_when_over = false
			intializer = FUNCTION
				goal = ARRAY
			
		HUMAN
			expandable = true
			variables_see_each_other = true
			name
			image
			physical_damage = 0
			mental_damage = 0
			reputation_level = 0
			reputation_points = 0
			mission_base_rating = 1
			money = 0
			lifestyle = 0
			age = 1           // age of this character in days
			skill_points = 0
			attack = 1
			defense = 1
			stealth = 1
			analysis = 1
			programming = 1
			chip_design = 1
			deck = DECK
			current_system
			current_area
			current_node
			current_target    // some ice or file
			current_program   // the program this human is currently trying to use
			time              // time for the current matrix run

// view data types
		
		VIEW                  // all variables in each view definition are optional
			expandable = true
			variables_see_each_other = true
			x
			y
			// width
			// height
			// title
			// background_image
			// object         // must contain an array which contains the interface elements of this view, e.g. buttons and lists
		
		BUTTON
			expandable = true
			variables_see_each_other = true
			x
			y
			state = IDLE
			idle              // the image for the idle state of the button. if the image name ends with a 0 and no pressed or disabled images are defined, the program will look for images of the same name but ending in a 1 and 2 for them
			component
			// pressed
			// disabled
			// hover
			// on_mouse_up    // put the function with the button effect here, for a standard button
			initializer = FUNCTION
				BUTTON.component = ARRAY
			on_draw = FUNCTION
				if state == IDLE
					if component[0] != idle
						component[0] = idle
				if state == PRESSED
					LOCAL.p = BUTTON.pressed  // using "BUTTON." to make sure we're not using the "pressed" variable from some other structure
					if p == UNDEFINED
						p = DEDUCE_IMAGE_NAME(BUTTON.idle, "1")    // deduces the name of the image for the pressed state from the name of the idle state image
					if component[0] != p
						component[0] = p
				if state == DISABLED
					LOCAL.p = BUTTON.disabled
					if p == UNDEFINED
						p = DEDUCE_IMAGE_NAME(BUTTON.idle, "2")
					if component[0] != p
						component[0] = p
				if state == HOVER
					LOCAL.p = BUTTON.hover
					if p == UNDEFINED
						p = DEDUCE_IMAGE_NAME(BUTTON.idle, "3")
					if component[0] != p
						component[0] = p

		TEXT
			expandable = true
			variables_see_each_other = true
			x
			y
			text
			// font           // a string, may contain several ; separated font settings (in arbitrary order, but later settings override earlier ones) : font face (Arial), font size (10pt) and font style (plain, bold, italic), e.g. "Arial;10pt;plain" or "bold;italic;Courier New;12pt". if style is omitted, plain is used. if font face or font size is omitted, the current settings are used, not the settings from the parent view element
			// color          // a color, using the html color format #rrggbb
			
		TEXTFIELD
			expandable = true
			variables_see_each_other = true
			x
			y
			width
			height
			user_input
			cursor                      // this is the cursor behind the text
			component
			// char_limit               // the maximum number of characters in the user input
			initializer = FUNCTION
				user_input = TEXT
					x = 1
					y = CENTER
					text = ""
				cursor = TEXT           // this is the cursor behind the text
					y = CENTER
					text = "_"
				component = ARRAY
					user_input
					cursor
			on_draw = FUNCTION
				if component[0] != user_input
					component[0] = user_input
				if component[1] != cursor
					component[1] = cursor
				cursor.x = user_input.x + pixelwidth(user_input)
			on_key_down = FUNCTION (key)
				if size(key) == 1 &&( char_limit == UNDEFINED || size(user_input.text) < char_limit )
					user_input.text = user_input.text + key
					if (TEXTFIELD.width != UNDEFINED) && (user_input.x + pixelwidth(user_input) + pixelwidth(cursor) > width)
						user_input.text = substring(user_input.text, 0, size(user_input.text)-1)    // the typed character doesn't fit into the field, discard it
				else if key == "BACKSPACE" && size(user_input.text) > 0
					user_input.text = substring(user_input.text, 0, size(user_input.text)-1)
					
		LINE
			x
			y
			x2
			y2
			color
		
		RECTANGLE
			x
			y
			width
			height
			color

		BORDER
			x
			y
			width
			height
			inverted = false
			color1 = @FETCH_BORDER_COLOR1
			color2 = @FETCH_BORDER_COLOR2
			object
			background_color
			component
			initializer = FUNCTION
// ***************
//				color1 = FETCH_BORDER_COLOR1
//				color2 = FETCH_BORDER_COLOR2
// ***************
				component = ARRAY
					LINE
					LINE
					LINE
					LINE
					LINE
					LINE
					LINE
					LINE
					UNDEFINED  // placeholder for the rectangle that draws the background, if it has a color
			on_draw = FUNCTION
				// adjust the lines if the border has changed
				LOCAL.c1 = inverted ? color2 : color1
				LOCAL.c2 = inverted ? color1 : color2
				LOCAL.corner_modifier = inverted ? 1 : 0
				if component[0].x2 != width-1 || component[2].y2 != height-1 || c1 != component[0].color || c2 != component[7].color
					set_line(component[0], 0, 0, width-1, 0, c1)    // the top border
					set_line(component[1], 1, 1, width-2, 1, c1)
					set_line(component[2], 0, 1, 0, height-1, c1)   // the left border
					set_line(component[3], 1, 2, 1, height-2, c1)
					set_line(component[4], width-1, 1-corner_modifier, width-1, height-1, c2)          // the right border
					set_line(component[5], width-2, 2-corner_modifier, width-2, height-2+corner_modifier, c2)
					set_line(component[6], 1-corner_modifier, height-1, width-2+corner_modifier, height-1, c2)    // the bottom border
					set_line(component[7], 2-corner_modifier, height-2, width-3+corner_modifier, height-2, c2)
				if background_color == UNDEFINED
					component[8] = UNDEFINED
				else if component[8].color != background_color
					if component[8] == UNDEFINED
						component[8] = RECTANGLE
					component[8].x = 2
					component[8].y = 2
					component[8].width = BORDER.width-4
					component[8].height = BORDER.height-4
					component[8].color = background_color

		SCREEN_BACKGROUND
			x = 0
			y = 0
			width
			height
			object
			component
			initializer = FUNCTION
				component = ARRAY
					create_border(0,0)
			on_draw = FUNCTION
				component[0].width = width
				component[0].height = height
				if BACKGROUND_COLOR2 == UNDEFINED
					component[0].background_color = @FETCH_BACKGROUND_COLOR
					if component[1] != UNDEFINED
						component[1] = UNDEFINED
				else
					if component[1] == UNDEFINED
						component[1] = create_border(5, 5, 0, 0)
					component[1].width = width-10
					component[1].height = height-10
					component[1].background_color = @FETCH_BACKGROUND_COLOR
					component[0].background_color = @FETCH_BACKGROUND_COLOR2
					
		BORDER_BUTTON
			expandable = true
			variables_see_each_other = true
			x
			y
			state = IDLE
			idle              // the image for the idle state of the button. if the image name ends with a 0 and no pressed or disabled images are defined, the program will look for images of the same name but ending in a 1 and 2 for them
			object
			// pressed
			// disabled
			// hover
			// on_mouse_up    // put the function with the button effect here, for a standard button
			initializer = FUNCTION
				BORDER_BUTTON.object = ARRAY
					create_border(0,0)
			on_draw = FUNCTION
				LOCAL.c = UNDEFINED
				if state == IDLE
					c = idle
				if state == PRESSED
					c = BUTTON.pressed  // using "BUTTON." to make sure we're not using the "pressed" variable from some other structure
					if c == UNDEFINED
						c = DEDUCE_IMAGE_NAME(idle, "1")    // deduces the name of the image for the pressed state from the name of the idle state image
				if state == DISABLED
					LOCAL.c = BUTTON.disabled
					if c == UNDEFINED
						c = DEDUCE_IMAGE_NAME(idle, "2")
				if state == HOVER
					LOCAL.c = BUTTON.hover
					if c == UNDEFINED
						c = DEDUCE_IMAGE_NAME(idle, "3")
				// if it's the name of an image, put a wrapper around it so we can position it within the button area
				if value_type(c) != "STRING"
					object[1] = c
				else if object[1].structure_type == COLLECTION
					object[1].object[0] = c
				else
					object[1] = COLLECTION
						object = ARRAY
							c
				
				object[0].inverted = state == PRESSED
				
				LOCAL.offset = (object[1].structure_type == "TEXT" ? 4 : 0)
				// if the button has an explicitly defined width, set the border width to the same value and center the button image / text horizontally
				if BORDER_BUTTON.width != UNDEFINED
					object[0].width = width
					object[1].x = CENTER
				else
					object[0].width = pixelwidth(object[1]) + 4 + 2*offset
					object[1].x = 2 + offset
				
				// if the button has an explicitly defined height, set the border height to the same value and center the button image / text vertically
				if BORDER_BUTTON.width != UNDEFINED
					object[0].height = height
					object[1].y = CENTER
				else     // otherwise, wrap a border around the content
					object[0].height = pixelheight(object[1]) + 4 + 2*offset
					object[1].y = 2 + offset/2
