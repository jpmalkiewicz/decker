english
// ****************************************************************************************************************************************************
// global functions ***********************************************************************************************************************************
// ****************************************************************************************************************************************************


	// this function makes a mission available if it has a target system with a rating or it has a mission rating the rating is within +/-2 or +/-20% of the player's preferred mission rating
	RULESET.defaultMissionAvailable = FUNCTION
		if rating != UNDEFINED
			return_value = ( rating >= player.mission_base_rating-2 || rating >= player.mission_base_rating*4/5 ) && ( rating <= player.mission_base_rating+2 || rating <= player.mission_base_rating*6/5 )
		else if target_system.rating != UNDEFINED
			return_value = ( target_system.rating >= player.mission_base_rating-2 || target_system.rating >= player.mission_base_rating*4/5 ) && ( target_system.rating <= player.mission_base_rating+2 || target_system.rating <= player.mission_base_rating*6/5 )

	// calculates the mission rating for missions which have a target system
	RULESET.defaultMissionRating = FUNCTION
		if target_system.structure_type == "SYSTEM"
			special_condition = 0
			target_count = 0
			// there's either one goal or an array of goals
			if goal.structure_type != "ARRAY" &&( goal.structure_type == "NO_RED_ALARM" || goal.structure_type == "CREATE_BACKDOOR" || goal.structure_type == "CRASH_SYSTEM" || goal.structure_type == "TIME_RESTRICTION" )	
				special_condition = goal.structure_type == "TIME_RESTRICTION" ? 2 : 1
			if goal.structure_type == "ARRAY"
				target_count = goal.size
				i = 0
				while i < goal.size
					if goal[i].structure_type == "NO_RED_ALARM" || goal[i].structure_type == "CREATE_BACKDOOR" || goal[i].structure_type == "CRASH_SYSTEM" || goal[i].structure_type == "TIME_RESTRICTION"
						special_condition = special_condition + ( goal.structure_type == "TIME_RESTRICTION" ? 2 : 1 )
						target_count = target_count - 1
					i = i + 1
			return_value = target_system.rating + target_count / 2 + special_condition

	// returns the name of the image to be displayed, deducing it from the state "0" image. e.g. deduceImageName("my_button0", "1") will return "my_button1" if an image "my_button1.*" exists, otherwise it returns "my_button0"
	RULESET.deduceImageName = FUNCTION (base_name, new_suffix)
		return_value = base_name
		// make sure it's not a structure. if it's a structure, just return it
		if base_name.structure_type == UNDEFINED
			base_name = base_name + ""    // turns it into a string
			LOCAL.k = indexof("0", base_name, false)
			return_value = base_name
			// check whether there's a "0" suffix, possibly followed by a supported image file type extension
			if k != UNDEFINED
				if k == size(base_name)-1
					// the "0" sits at the end of the string
					if image_exists(substring(base_name,0,k) + new_suffix)
						return_value = substring(base_name,0,k) + new_suffix
				else
					// check whether there's a file type extension after the "0", otherwise the "0" is not a suffix and we'll just return the base_name
					LOCAL.file_type = to_lower_case(base_name.substring(k+1))
					if file_type == ".gif" || file_type == ".png" || file_type == ".bmp" ||file_type == ".jpg" || file_type == ".jpeg"
						if image_exists(substring(base_name,0,k) + new_suffix)
							return_value = substring(base_name,0,k) + new_suffix
							
// ****************************************************************************************************************************************************
// structure types ************************************************************************************************************************************
// ****************************************************************************************************************************************************


	structure
		COLLECTION
			expandable = true
		
		GLOBAL
			expandable = true
	
// mission goal types *********************************************************************************************************************************

		CRASH_SYSTEM
			status = INCOMPLETE
			incomplete
			completed		

		CREATE_BACKDOOR            extends CRASH_SYSTEM

		DOWNLOAD_FILE              extends CRASH_SYSTEM
			target
	
		DOWNLOAD_AND_ERASE_FILE    extends DOWNLOAD_FILE
	
		EDIT_FILE                  extends DOWNLOAD_FILE

		ERASE_FILE                 extends DOWNLOAD_FILE

		MANIPULATE_IO              extends DOWNLOAD_FILE
	
		RUN_PROGRAM                extends DOWNLOAD_FILE
			program
			execution_time
			remaining_execution_time
		
		NO_RED_ALARM
			status = COMPLETED
			completed
			failed

		TIME_RESTRICTION
			start_time
			end_time
			status = COMPLETED
			completed
			incomplete
			failed

// system related types *******************************************************************************************************************************

		SYSTEM_TYPE
			name
			file
			deactivate_io_target
			activate_io_target
			sabotage_io_target
			useless_file

		SYSTEM
			name
			rating
			type
			status = GREEN
			area
			initializer = FUNCTION
				area = ARRAY
			
		AREA
			name
			system
			destroyed_ice
			ice_entry_node
			
		NODE
			name
			area
			smoke_level
			objects       // ice and humans
		
		FILE
			name
			type
			description
			size
			value = 0
			
		ICE
			expandable = true
			name
			rating
			damage = 0
			node
			// hardened
			// phasing
			// trace_time
			// trace_target
			
// miscellaneous types ********************************************************************************************************************************

		THING_TYPE
			type_name
			category               // an array listing all the categories this thing type belongs to
			value                  // a function to calculate the value of things of this type
			size                   // a function to calculate the size of things of this type
			default_name           // an array : default_name[x] is the default name of a thing of this type and item_rating x
			effect                 // a function that gets executed when things of this type are used
			sorting_priority       //integer. determines the default order of items in displayed lists (shop, a deck's loaded programs, ...)
		
		THING
			expandable = true
			name
			type           // a THING_TYPE object
			rating
			size
			status         // price if it's in the shop, status if it's a program in the deck (INSTALLED, LOADED, RUNNING)
			
		DECK
			model = "(custom built)"
			damage = 0
			current_load = 0  // 0 = light, 1 = medium, 2 = high
			cpu = 1
			coprocessor = 1
			attack = 1
			defense = 1
			stealth = 1
			analysis = 1
			program
			intializer = FUNCTION
				program = ARRAY
			
		MISSION
			expandable = true
			variables_see_each_other = true
			available = @DEFAULT_MISSION_AVAILABLE
			status = INCOMPLETE
			can_be_started = true
			title
			description
			payment
			target_system
			filename                // name of the script this mission comes from
			goal
			rating = @DEFAULT_MISSION_RATING
			deadline = 5
			can_be_dropped = true
			age = 0
			failed_attempts = 0
			reload_when_over = false
			intializer = FUNCTION
				goal = ARRAY
			
		HUMAN
			expandable = true
			variables_see_each_other = true
			name
			image
			physical_damage = 0
			mental_damage = 0
			reputation_level = 0
			reputation_points = 0
			mission_base_rating = 1
			money = 0
			lifestyle = 0
			age = 1           // age of this character in days
			skill_points = 0
			attack = 1
			defense = 1
			stealth = 1
			analysis = 1
			programming = 1
			chip_design = 1
			deck
			current_system
			current_area
			current_node
			current_target    // some ice or file
			current_program   // the program this human is currently trying to use
			time              // time for the current matrix run


// view data types ************************************************************************************************************************************


		DRAWING_BOUNDARY // limits the area where things can be drawn to the given rectangle. all drawings which are in the object array of the DRAWING_BOUNDARY get cut off at the edge of the rectangle and only display inside
			x
			y
			width
			height
			object
			initializer = FUNCTION
				object = ARRAY
		

		VIEW                  // all variables in each view definition are optional
			expandable = true
			variables_see_each_other = true
			x
			y
			// width
			// height
			// title
			// background_image
			// object         // must contain an array which contains the interface elements of this view, e.g. buttons and lists
		
		BUTTON
			expandable = true
			variables_see_each_other = true
			x
			y
			state = IDLE
			idle              // the image for the idle state of the button. if the image name ends with a 0 and no pressed or disabled images are defined, the program will look for images of the same name but ending in a 1 and 2 for them
			component
			// pressed
			// disabled
			// hover
			// on_mouse_up    // put the function with the button effect here, for a standard button
			initializer = FUNCTION
				BUTTON.component = ARRAY
			on_draw = FUNCTION
				if state == IDLE
					if component[0] != idle
						component[0] = idle
				if state == PRESSED
					LOCAL.p = BUTTON.pressed  // using "BUTTON." to make sure we're not using the "pressed" variable from some other structure
					if p == UNDEFINED
						p = deduceImageName(BUTTON.idle, "1")    // deduces the name of the image for the pressed state from the name of the idle state image
					if component[0] != p
						component[0] = p
				if state == DISABLED
					LOCAL.p = BUTTON.disabled
					if p == UNDEFINED
						p = deduceImageName(BUTTON.idle, "2")
					if component[0] != p
						component[0] = p
				if state == HOVER
					LOCAL.p = BUTTON.hover
					if p == UNDEFINED
						p = deduceImageName(BUTTON.idle, "3")
					if component[0] != p
						component[0] = p

		TEXT
			expandable = true
			variables_see_each_other = true
			x
			y
			text
			// font           // a string, may contain several ; separated font settings (in arbitrary order, but later settings override earlier ones) : font face (Arial), font size (10pt) and font style (plain, bold, italic), e.g. "Arial;10pt;plain" or "bold;italic;Courier New;12pt". if style is omitted, plain is used. if font face or font size is omitted, the current settings are used, not the settings from the parent view element
			// color          // a color, using the html color format #rrggbb
			
		TEXTFIELD
			expandable = true
			variables_see_each_other = true
			x
			y
			width
			height
			user_input
			cursor                      // this is the cursor behind the text
			component
			// char_limit               // the maximum number of characters in the user input
			initializer = FUNCTION
				user_input = TEXT
					x = 1
					y = CENTER
					text = ""
				cursor = TEXT           // this is the cursor behind the text
					y = CENTER
					text = "_"
				component = ARRAY
					user_input
					cursor
			on_draw = FUNCTION
				if component[0] != user_input
					component[0] = user_input
				if component[1] != cursor
					component[1] = cursor
				cursor.x = user_input.x + pixelwidth(user_input)
			on_key_down = FUNCTION (key)
				if size(key) == 1 &&( char_limit == UNDEFINED || size(user_input.text) < char_limit )
					user_input.text = user_input.text + key
					if (TEXTFIELD.width != UNDEFINED) && (user_input.x + pixelwidth(user_input) + pixelwidth(cursor) > width)
						user_input.text = substring(user_input.text, 0, size(user_input.text)-1)    // the typed character doesn't fit into the field, discard it
				else if key == "BACKSPACE" && size(user_input.text) > 0
					user_input.text = substring(user_input.text, 0, size(user_input.text)-1)
					
		LINE
			x
			y
			x2
			y2
			color
		
		RECTANGLE
			x
			y
			width
			height
			color

		BORDER
			x
			y
			width
			height
			inverted = false
			color1 = @BORDER_COLOR1
			color2 = @BORDER_COLOR2
			object
			background_color
			component
			initializer = FUNCTION
				component = ARRAY
					LINE
					LINE
					LINE
					LINE
					LINE
					LINE
					LINE
					LINE
					UNDEFINED  // placeholder for the rectangle that draws the background, if it has a color
			on_draw = FUNCTION
				// adjust the lines if the border has changed
				LOCAL.c1 = inverted ? color2 : color1
				LOCAL.c2 = inverted ? color1 : color2
				LOCAL.corner_modifier = inverted ? 1 : 0
				if component[0].x2 != width-1 || component[2].y2 != height-1 || c1 != component[0].color || c2 != component[7].color
					setLine(component[0], 0, 0, width-1, 0, c1)    // the top border
					setLine(component[1], 1, 1, width-2, 1, c1)
					setLine(component[2], 0, 1, 0, height-1, c1)   // the left border
					setLine(component[3], 1, 2, 1, height-2, c1)
					setLine(component[4], width-1, 1-corner_modifier, width-1, height-1, c2)          // the right border
					setLine(component[5], width-2, 2-corner_modifier, width-2, height-2+corner_modifier, c2)
					setLine(component[6], 1-corner_modifier, height-1, width-2+corner_modifier, height-1, c2)    // the bottom border
					setLine(component[7], 2-corner_modifier, height-2, width-3+corner_modifier, height-2, c2)
				if background_color == UNDEFINED
					component[8] = UNDEFINED
				else if component[8].color != background_color
					if component[8] == UNDEFINED
						component[8] = RECTANGLE
					component[8].x = 2
					component[8].y = 2
					component[8].width = BORDER.width-4
					component[8].height = BORDER.height-4
					component[8].color = background_color


		SCREEN_BACKGROUND
			x = 0
			y = 0
			width
			height
			object
			component
			initializer = FUNCTION
				component = ARRAY
					createBorder(0,0)
			on_draw = FUNCTION
				component[0].width = width
				component[0].height = height
				if BACKGROUND_COLOR2 == UNDEFINED
					component[0].background_color = @BACKGROUND_COLOR
					if component[1] != UNDEFINED
						component[1] = UNDEFINED
				else
					if component[1] == UNDEFINED
						component[1] = createBorder(5, 5, 0, 0)
					component[1].width = width-10
					component[1].height = height-10
					component[1].background_color = @BACKGROUND_COLOR
					component[0].background_color = @BACKGROUND_COLOR2
					
		BORDER_BUTTON
			expandable = true
			variables_see_each_other = true
			x
			y
			state = IDLE
			idle              // the image for the idle state of the button. if the image name ends with a 0 and no pressed or disabled images are defined, the program will look for images of the same name but ending in a 1 and 2 for them
			object
			// pressed
			// disabled
			// hover
			// on_mouse_up    // put the function with the button effect here, for a standard button
			initializer = FUNCTION
				BORDER_BUTTON.object = ARRAY
					createBorder(0,0)
			on_draw = FUNCTION
				LOCAL.c = UNDEFINED
				if state == IDLE
					c = idle
				if state == PRESSED
					c = BUTTON.pressed  // using "BUTTON." to make sure we're not using the "pressed" variable from some other structure
					if c == UNDEFINED
						c = deduceImageName(idle, "1")    // deduces the name of the image for the pressed state from the name of the idle state image
				if state == DISABLED
					LOCAL.c = BUTTON.disabled
					if c == UNDEFINED
						c = deduceImageName(idle, "2")
				if state == HOVER
					LOCAL.c = BUTTON.hover
					if c == UNDEFINED
						c = deduceImageName(idle, "3")
				// if it's the name of an image, put a wrapper around it so we can position it within the button area
				if value_type(c) != "STRING"
					object[1] = c
				else if object[1].structure_type == COLLECTION
					object[1].object[0] = c
				else
					object[1] = COLLECTION
						object = ARRAY
							c
				
				object[0].inverted = state == PRESSED
				
				LOCAL.offset = (object[1].structure_type == "TEXT" ? 4 : 0)
				// if the button has an explicitly defined width, set the border width to the same value and center the button image / text horizontally
				if BORDER_BUTTON.width != UNDEFINED
					object[0].width = width
					object[1].x = CENTER
				else
					object[0].width = pixelwidth(object[1]) + 4 + 2*offset
					object[1].x = 2 + offset
				
				// if the button has an explicitly defined height, set the border height to the same value and center the button image / text vertically
				if BORDER_BUTTON.width != UNDEFINED
					object[0].height = height
					object[1].y = CENTER
				else     // otherwise, wrap a border around the content
					object[0].height = pixelheight(object[1]) + 4 + 2*offset
					object[1].y = 2 + offset/2



//*****************************************************************************************************************************************************
//***    TABLE    *************************************************************************************************************************************
//*****************************************************************************************************************************************************



		TABLE
			x = 0
			y = 0
			v_align
			h_align
			cell_height   // all rows have the same height
			cell_width    // array containing the width for each column
			cell_h_align // default horizontal alignment of cell content. if it's defined in an ARRAY it's entries are used as the default horizontal alignment of cell content for each column. this value will only be used if the cell content doesn't have a valid value for v_align. watch out, the alginment setting gets set for the cell content. if the same thing is displayed in different cells (even from different tables), the cell that gets displayed first determines its alignment, if cell_alignment_x is set
			cell_v_align // default vertical alignment of cell content, works like cell_h_align
			cell_x // x value of cell content. works like cell_h_align
			cell_y // y value of cell content. works like cell_h_align
			width = 0
			height = 0
			component
			initializer = FUNCTION
				component = ARRAY


//*****************************************************************************************************************************************************
//***    SCROLLBAR    &    SCROLL_PANE    *************************************************************************************************************
//*****************************************************************************************************************************************************


		SCROLLBAR  // a vertical scrollbar
			x
			y
			width
			height
			v_align
			h_align
			component  // component[0] = scroller, [1] = up arrow (optional), [2] = down arrow (optional), [3] is an invisible rectangle that spans the whole screen to capture on_mouse_dragged events
			object
			on_draw
			slider_position = 0  // logical position
			slider_max           // you HAVE to set this to a positive number or the slider won't work
			slider_stepping = 20 // this is the amount by which slider_position will change each time you press one of the arrow buttons
			effect               // put a function here. it gets called whenever the slider_position changes
			slider_dragging      // the scrollbar automatically sets this variable when the user starts / stops dragging the slider
			initializer = FUNCTION
				on_draw = FUNCTION
					scrollbarDrawFunction(SCROLLBAR.this)
				component = ARRAY
					UNDEFINED  // slider
					UNDEFINED  // up arrow, optional
					UNDEFINED  // down arrow, optional
					COLLECTION // this is an invisible rectangle that spans the whole screen to capture on_mouse_dragged events
						variables_see_each_other = true
						x = -1000000
						y = x
						width = -2*x
						height = width
						on_mouse_dragged = FUNCTION (mouse_x, mouse_y, dx, dy)
							if slider_dragging != UNDEFINED
								// calculate the coordinates of the mouse relative to the scrollbar
								LOCAL.my = mouse_y+y-slider_dragging
								LOCAL.miny = pixelheight(SCROLLBAR.component[1])  // the height of the up arrow
								// adjust the logical slider position to its new physical position
								LOCAL.logical_y = ((my-miny) * slider_max) / (SCROLLBAR.height - miny - pixelheight(component[0]) - pixelheight(component[2]))
								if logical_y < 0
									logical_y = 0
								if logical_y > slider_max
									logical_y = slider_max
								if slider_position != logical_y
									slider_position = logical_y
						on_mouse_up = FUNCTION
							slider_dragging = UNDEFINED    // capture on_mouse_up events here, to stop dragging the slider
