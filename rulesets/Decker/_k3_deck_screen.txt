english
	RULESET.deck_screen = COMPONENT
		title = "Decker - Deck"
				
		LOCAL.screen_width = 540
		LOCAL.screen_height = 445
				
		back_button = BORDER_BUTTON
			x = screen_width - 18 - 24
			y = screen_height - 18 - 24
			idle = "home/home"
			on_mouse_up = FUNCTION
				displayPreviousScreen()

		scrollpane = SCROLLPANE
			x = 20
			y = 180
			width = 405
			height = screen_height - y - 80    // make the height relative to the screenheight
			vertical_scrollbar = ARRAY
				"scroller_vertical_blue0"
				"scroller_up_blue0"
				"scroller_down_blue0"
			displayed_element = test_table
			
		LOCAL.createTableButton = FUNCTION (_text, _width, _x, _sorting_order_function)
			return_value = BORDER_BUTTON
				x = _x[0]
				y = _x[1] - 21
				idle = createText(_text)
				idle.height = 14
				width = _width
				height = 20
				_x[0] = _x[0] + _width
				sorting_order_function = &_sorting_order_function
				on_mouse_up = FUNCTION
					sortTable(scrollpane.displayed_element, &sorting_order_function)

		LOCAL.table_button_x = ARRAY
			scrollpane.x - 1
			scrollpane.y
			
		current_load_text = createText("", scrollpane.x+100, screen_height-68)
		load_0_text = createText("", scrollpane.x+scrollpane.width, current_load_text.y, , , LEFT)
		load_1_text = createText("", scrollpane.x+scrollpane.width, current_load_text.y+18, , , LEFT)
		load_2_text = createText("", scrollpane.x+scrollpane.width, current_load_text.y+18*2, , , LEFT)
		optional_hardware = COLLECTION
		trashcan_wrapper = COMPONENT
			
		component = ARRAY
			SCREEN_BACKGROUND
				width = screen_width
				height = screen_height
			back_button
			trashcan_wrapper
			BORDER_BUTTON
				x = back_button.x - 10 - 24
				y = back_button.y
				idle = "home/char"
				on_mouse_up = FUNCTION
					displayInitializedScreen(character_screen, false)

			// the hardware section
			createText("Chips",       20, 15)
			createText("CPU",         28, 17+16*1)
			createText("Coprocessor", 28, 17+16*2)
			createText("Attack",      28, 17+16*3)
			createText("Defense",     28, 17+16*4)
			createText("Stealth",     28, 17+16*5)
			createText("Analysis",    28, 17+16*6)

			// the software section
			createBorder(scrollpane.x-3, scrollpane.y-23, scrollpane.width+6, scrollpane.height+26, @TABLE_BACKGROUND_COLOR, true)
			scrollpane
			createTableButton("",        20, table_button_x, &compareProgramsPreset)
			createTableButton("Name",   117, table_button_x, &compareProgramsName)
			createTableButton("Type",    54, table_button_x, &compareProgramsType)
			createTableButton("Rating",  54, table_button_x, &compareProgramsRating)
			createTableButton("Size",    54, table_button_x, &compareProgramsSize)
			createTableButton("Loaded",  54, table_button_x, &compareProgramsLoaded)
			createTableButton("Default", 54, table_button_x, &compareProgramsDefault)
			optional_hardware   // the optional hardware texts will be stored in optional_hardware.component
			
			// the current load section
			createText("Current Load", scrollpane.x, current_load_text.y)
			current_load_text
			createText(LOAD_TEXT[0]+" Load", load_0_text.x-155, load_0_text.y)
			load_0_text
			createText(LOAD_TEXT[1]+" Load", load_1_text.x-155, load_1_text.y)
			load_1_text
			createText(LOAD_TEXT[2]+" Load", load_2_text.x-155, load_2_text.y)
			load_2_text
					
		chip_text = ARRAY
		LOCAL.i = 0
		while i < 6
			chip_text[i] = createText("1", 130, 32+i*16, UNDEFINED, UNDEFINED, RIGHT)
			chip_text[i].h_align = LEFT
			component[] = chip_text[i]
			i = i + 1
			
			
		setup = FUNCTION
			updateBackButton(deck_screen.back_button)
			deck_screen.chip_text[0].text = player.deck.cpu
			deck_screen.chip_text[1].text = player.deck.coprocessor
			deck_screen.chip_text[2].text = player.deck.attack
			deck_screen.chip_text[3].text = player.deck.defense
			deck_screen.chip_text[4].text = player.deck.stealth
			deck_screen.chip_text[5].text = player.deck.analysis
			deck_screen.current_load_text.text = LOAD_TEXT[player.deck.current_load] + " / " + player.deck.used_memory
			LOCAL.i = getMaxLoad(player.deck)
			deck_screen.load_0_text.text = i/3
			deck_screen.load_1_text.text = i*2/3
			deck_screen.load_2_text.text = i
			deck_screen.optional_hardware.component = ARRAY
			LOCAL.h = player.deck.optional_hardware
			if h.size > 0
				LOCAL.xoff = h.size <= 6 ? 210 : 200
				LOCAL.second_column = h.size <= 6 ? h.size : (h.size+1)/2
				deck_screen.optional_hardware.component[] = createText("Optional Hardware", xoff-8, 15)
				if h.size > 6
					deck_screen.optional_hardware.component[0].x = xoff+140
					deck_screen.optional_hardware.component[0].h_align = CENTER
				i = 0
				while i < second_column
					deck_screen.optional_hardware.component[] = createText(player.deck.optional_hardware[i].name, xoff, 17+(i+1)*16)
					i = i + 1
				while i < player.deck.optional_hardware.size
					deck_screen.optional_hardware.component[] = createText(player.deck.optional_hardware[i].name, xoff+160, 17+(i+1-second_column)*16)
					i = i + 1
			
			// create the new software table ***********************************************************************************************************
			LOCAL.t = createTable ( , 18, 19, 116, 54, 54, 54, 54, 54)
			t.cell_x = createArray (CENTER, 8, CENTER, CENTER, CENTER, CENTER, CENTER)
			t.cell_y = CENTER
			t.selected_row_background = @TABLE_SELECTED_ROW_BACKGROUND
			t.can_drag_rows = true
			t.on_row_drag = FUNCTION (table, old_row_index, new_row_index)
				// rearrange the programs n the player deck accordingly
				LOCAL.p = player.deck.program
				LOCAL.backup = p[old_row_index]
				LOCAL.i = old_row_index
				if old_row_index > new_row_index
					while i > new_row_index
						p[i] = p[i-1]
						i = i - 1
				else
					while i < new_row_index
						p[i] = p[i+1]
						i = i + 1
				p[new_row_index] = backup
			t.on_selection_change = FUNCTION (table, old_selected_row, new_selected_row)
				if new_selected_row >= 0 && new_selected_row < table.rows
					if trashcan_wrapper.component == UNDEFINED
						trashcan_wrapper.component = BORDER_BUTTON
							x = scrollpane.x-3
							y = back_button.y
							idle = "trashcan0"
							on_mouse_up = FUNCTION
								trashcan_wrapper.component = UNDEFINED
				else
					trashcan_wrapper.component = UNDEFINED
					
			LOCAL.p = player.deck.program
			LOCAL.state = UNDEFINED
			LOCAL.loaded = UNDEFINED
			
			LOCAL.default_function = FUNCTION
				if prog.state == DEFAULT
					setProgramState(player.deck, prog, LOADED)
					idle = "status_off"
				else
					// switch off the default marker for the old default program in the table
					LOCAL.p2 = player.deck.default_program[prog.type.default_category]
					if p2 != UNDEFINED
						LOCAL.index = indexof(p2, player.deck.program)
						getTableCell(deck_screen.scrollpane.displayed_element, index, 6).idle = "status_off"
					// if the program wasn't loaded, change the load marker
					if prog.state == INSTALLED
						LOCAL.index = indexof(prog, player.deck.program)
						getTableCell(deck_screen.scrollpane.displayed_element, index, 5).idle = "status_on"
					setProgramState(player.deck, prog, DEFAULT)
					idle = "status_on"
					deck_screen.current_load_text.text = LOAD_TEXT[player.deck.current_load] + " / " + player.deck.used_memory
				
			LOCAL.load_function = FUNCTION
				if prog.state == DEFAULT
					LOCAL.index = indexof(prog, player.deck.program)
					getTableCell(deck_screen.scrollpane.displayed_element, index, 6).idle = "status_off"
				setProgramState(player.deck, prog, prog.state != INSTALLED ? INSTALLED : LOADED)
				idle = prog.state == INSTALLED ? "status_off" : "status_on"
				deck_screen.current_load_text.text = LOAD_TEXT[player.deck.current_load] + " / " + player.deck.used_memory
			
			i = 0
			while i < p.size
				loaded = BUTTON
					idle = p[i].state != INSTALLED ?  "status_on"  :  "status_off"
					prog = p[i]
					on_mouse_down = &load_function
				if p[i].type.default_category != UNDEFINED
					state = BUTTON
						idle = p[i].state == DEFAULT  ?  "status_on"  :  "status_off"
						prog = p[i]
						on_mouse_down = &default_function
				else
					state = createText("")
				
				addTableRow(t, p[i].type.image, createText(p[i].name,,,@TABLE_TEXT_COLOR), createText(p[i].type.name,,,@TABLE_TEXT_COLOR), createText(p[i].rating,,,@TABLE_TEXT_COLOR), createText(p[i].size,,,@TABLE_TEXT_COLOR), loaded, state)
				i = i + 1
			deck_screen.scrollpane.displayed_element = t
