english

	structure
		COLLECTION
			expandable = true


		GLOBAL
			expandable = true


// interface element types ****************************************************************************************************************************


		DRAWING_BOUNDARY // limits the area where things can be drawn to the given rectangle. all drawings which are in the component array of the DRAWING_BOUNDARY get cut off at the edge of the rectangle and only display inside
			x
			y
			width
			height
			component


		COMPONENT             // all variables in each view definition are optional
			expandable = true
			x
			y
			// width
			// height
			// title             // only relevant if it is the top level component. then it sets the frame title
			// background_image
			// component         // must contain an array which contains the interface elements of this view, e.g. buttons and lists


		BUTTON
			expandable = true
			x
			y
			state = IDLE
			idle              // the image for the idle state of the button. if the image name ends with a 0 and no pressed or disabled images are defined, the program will look for images of the same name but ending in a 1 and 2 for them
			component
			// pressed
			// disabled
			// hover
			// on_mouse_up    // put the function with the button effect here, for a standard button
			initializer = FUNCTION
				component = ARRAY
					UNDEFINED
			on_draw = FUNCTION
				if state == IDLE
					if component[0] != idle
						component[0] = idle
				if state == PRESSED
					LOCAL.p = BUTTON.pressed  // using "BUTTON." to make sure we're not using the "pressed" variable from some other structure
					if p == UNDEFINED
						p = deduceImageName(idle, "1")    // deduces the name of the image for the pressed state from the name of the idle state image
					if component[0] != p
						component[0] = p
				if state == DISABLED
					LOCAL.p = BUTTON.disabled
					if p == UNDEFINED
						p = deduceImageName(idle, "2")
					if component[0] != p
						component[0] = p
				if state == HOVER
					LOCAL.p = BUTTON.hover
					if p == UNDEFINED
						p = deduceImageName(idle, "3")
					if component[0] != p
						component[0] = p


		TEXT
			expandable = true
			x
			y
			text
			// font           // a string, may contain several ; separated font settings (in arbitrary order, but later settings override earlier ones) : font face (Arial), font size (10pt) and font style (plain, bold, italic), e.g. "Arial;10pt;plain" or "bold;italic;Courier New;12pt". if style is omitted, plain is used. if font face or font size is omitted, the current settings are used, not the settings from the parent view element
			// color          // a color, using the html color format #rrggbb
			

		TEXTFIELD
			expandable = true
			x
			y
			width
			height
			user_input
			cursor                      // this is the cursor behind the text
			component
			// char_limit               // the maximum number of characters in the user input
			initializer = FUNCTION
				user_input = TEXT
					x = 1
					y = CENTER
					text = ""
				cursor = TEXT           // this is the cursor behind the text
					y = CENTER
					text = "_"
				component = ARRAY
					user_input
					cursor
			on_draw = FUNCTION
				if component[0] != user_input
					component[0] = user_input
				if component[1] != cursor
					component[1] = cursor
				cursor.x = user_input.x + pixelwidth(user_input)
			on_key_down = FUNCTION (key)
				if size(key) == 1 &&( char_limit == UNDEFINED || size(user_input.text) < char_limit )
					user_input.text = user_input.text + key
					if (TEXTFIELD.width != UNDEFINED) && (user_input.x + pixelwidth(user_input) + pixelwidth(cursor) > width)
						user_input.text = substring(user_input.text, 0, size(user_input.text)-1)    // the typed character doesn't fit into the field, discard it
				else if key == "BACKSPACE" && size(user_input.text) > 0
					user_input.text = substring(user_input.text, 0, size(user_input.text)-1)


		LINE
			x
			y
			x2
			y2
			color


		RECTANGLE
			x
			y
			width
			height
			color


		BORDER
			x
			y
			width
			height
			inverted = false
			top_color = @BORDER_COLOR1
			left_color
			right_color
			bottom_color = @BORDER_COLOR2
			background_color
			component
			thickness = 2


		SCREEN_BACKGROUND
			x = 0
			y = 0
			width
			height
			component
			initializer = FUNCTION
				component = ARRAY
					createBorder(0,0)
			on_draw = FUNCTION
				component[0].width = width
				component[0].height = height
				if BACKGROUND_COLOR2 == UNDEFINED
					component[0].background_color = @BACKGROUND_COLOR
					if component[1] != UNDEFINED
						component[1] = UNDEFINED
				else
					if component[1] == UNDEFINED
						component[1] = createBorder(5, 5, 0, 0)
					component[1].width = width-10
					component[1].height = height-10
					component[1].background_color = @BACKGROUND_COLOR
					component[0].background_color = @BACKGROUND_COLOR2


		BORDER_BUTTON
			expandable = true
			x
			y
			component
			state = IDLE
			idle              // the image for the idle state of the button. if the image name ends with a 0 and no pressed, hover or disabled images are defined, the program will look for images of the same name but ending in a 1, 2 and 3 for them
			// pressed
			// disabled
			// hover
			// on_mouse_up    // put the function with the button effect here, for a standard button
			// text_padding    // put a value here if you want the text to be shifted a different number of pixels than 4 from the top
			initializer = FUNCTION
				component = ARRAY
					createBorder(0,0)
					UNDEFINED    // placeholder for the button face
				component[0].background_color = @BACKGROUND_COLOR
			on_draw = FUNCTION
				LOCAL.c = UNDEFINED
				if state == IDLE
					c = idle
				if state == PRESSED
					c = BUTTON.pressed  // using "BUTTON." to make sure we're not using the "pressed" variable from some other structure
					if c == UNDEFINED
						c = deduceImageName(idle, "1")    // deduces the name of the image for the pressed state from the name of the idle state image
				if state == DISABLED
					LOCAL.c = BUTTON.disabled
					if c == UNDEFINED
						c = deduceImageName(idle, "2")
				if state == HOVER
					LOCAL.c = BUTTON.hover
					if c == UNDEFINED
						c = deduceImageName(idle, "3")
				// if it's the name of an image, put a wrapper around it so we can position it within the button area
				if value_type(c) != "STRING"
					component[1] = c
				else if component[1].structure_type == COLLECTION
					component[1].component = c
				else
					component[1] = COLLECTION
						component = c
				component[0].inverted = state == PRESSED
				LOCAL.padding = BORDER_BUTTON.text_padding != UNDEFINED && component[1].structure_type == "TEXT" ? text_padding : 0
				// if the button has an explicitly defined width, set the border width to the same value and center the button image / text horizontally
				if BORDER_BUTTON.width != UNDEFINED
					component[0].width = width
					component[1].x = CENTER
				else
					component[0].width = pixelwidth(component[1]) + 4 + 2*padding
					component[1].x = 2 + padding
				// if the button has an explicitly defined height, set the border height to the same value and center the button image / text vertically
				if BORDER_BUTTON.height != UNDEFINED
					component[0].height = height
					component[1].y = CENTER
				else     // otherwise, wrap a border around the content
					component[0].height = pixelheight(component[1]) + 4 + 2*padding
					component[1].y = 2 + padding/2


		TABLE
			expandable = true
			rows          // number of rows in this table
			columns       // number of columns in this table
			cell          // two dimensional array containing the cells
			cell_height   // all rows have the same height
			cell_width    // array containing the width for each column
			//cell_h_align // default horizontal alignment of cell content. if it's defined in an ARRAY it's entries are used as the default horizontal alignment of cell content for each column. this value will only be used if the cell content doesn't have a valid value for v_align. watch out, the alignment setting gets set for the cell content. if the same thing is displayed in different cells (even from different tables), the cell that gets displayed first determines its alignment, if cell_alignment_x is set
			//cell_v_align // default vertical alignment of cell content, works like cell_h_align
			//cell_x // x value of cell content. works like cell_h_align
			//cell_y // y value of cell content. works like cell_h_align
			width = 0
			height = 0


		SCROLLBAR  // a vertical scrollbar
			x
			y
			width
			height
			v_align
			h_align
			component  // component[0] = scroller, [1] = up arrow (optional), [2] = down arrow (optional), [3] is an invisible rectangle that spans the whole screen to capture on_mouse_dragged events
			on_draw
			slider_position = 0  // logical position
			slider_max           // you HAVE to set this to a positive number or the slider won't work
			slider_stepping = 20 // this is the amount by which slider_position will change each time you press one of the arrow buttons
			effect               // put a function here. it gets called whenever the slider_position changes
			slider_dragging      // the scrollbar automatically sets this variable when the user starts / stops dragging the slider
			vertical = true      // false -> the scrollbar is horizontal
			initializer = FUNCTION
				on_draw = FUNCTION
					scrollbarDrawFunction(SCROLLBAR.this)
				component = ARRAY
					UNDEFINED  // slider
					UNDEFINED  // up/left arrow, optional
					UNDEFINED  // down/right arrow, optional
					COLLECTION // this is an invisible rectangle that spans the whole screen to capture on_mouse_dragged events
						x = -1000000
						y = x
						width = -2*x
						height = width
						on_mouse_dragged = FUNCTION (mouse_x, mouse_y, dx, dy)
							if slider_dragging != UNDEFINED
								// calculate the coordinates of the mouse relative to the scrollbar
								LOCAL.dm = ( vertical ? mouse_y+y : mouse_x+x ) - slider_dragging
								LOCAL.pmin = vertical ? pixelheight(SCROLLBAR.component[1]) : pixelwidth(SCROLLBAR.component[1]) // physical minimum of the slider position, determined by the height/width of the up/left arrow
								// adjust the logical slider position to its new physical position
								if vertical
									LOCAL.logical = ((dm-pmin) * slider_max) / (SCROLLBAR.height - pmin - pixelheight(component[0]) - pixelheight(component[2]))
								else
									LOCAL.logical = ((dm-pmin) * slider_max) / (SCROLLBAR.width - pmin - pixelwidth(component[0]) - pixelwidth(component[2]))
								if logical < 0
									logical = 0
								if logical > slider_max
									logical = slider_max
								if slider_position != logical
									slider_position = logical
								if effect != UNDEFINED
									effect(SCROLLBAR.this, slider_position)
						on_mouse_up = FUNCTION
							slider_dragging = UNDEFINED    // capture on_mouse_up events here, to stop dragging the slider
			pixelwidth = FUNCTION
				return_value = width
				// we can only guess the width if the scrollbar is vertical
				if return_value == UNDEFINED && vertical
					return_value = max( pixelwidth(SCROLLBAR.component[0]), pixelwidth(SCROLLBAR.component[1]), pixelwidth(SCROLLBAR.component[2]) )
			pixelheight = FUNCTION
				return_value = height
				// we can only guess the height if the scrollbar is horizontal
				if return_value == UNDEFINED && !vertical
					return_value = max( pixelheight(SCROLLBAR.component[0]), pixelheight(SCROLLBAR.component[1]), pixelheight(SCROLLBAR.component[2]) )


		SCROLLPANE
			x
			y
			width
			height
			component                            // component[2] optional vertical scrollbar, component[3] optional horizontal scrollbar, component[1] optional view element that gets displayed in the corner that is cut off if both scrollbars are displayed, component[0] a DRAWING_BOUNDARY with component[0].component being a wrapper around the view element that is displayed in this scrollpane
			displayed_element                    // the component that this SCROLLPANE displays
			optional_scrollbars = true           // the scrollbars are optional by default and only get displayed when needed
			vertical_scrollbar                   // either a scrollbar or an array containing the slider and buttons, or their names
			horizontal_scrollbar                 // like vertical_scrollbar
			corner_filler                        // component to be displayed in the cornerthat gets get cut off when both scrollbars are displayed
			scrollbar_padding = 1                // number of pixels to be put left empty between the DRAWING_PANE and the scrollbar
			initializer = FUNCTION
				component = ARRAY
					DRAWING_BOUNDARY
						x = 0
						y = 0
						component = COMPONENT   // wraps around the displayed component to be able to move it around on the screen without changing it
							x = 0
							y = 0
							component = UNDEFINED  // the displayed component
					UNDEFINED
					UNDEFINED
					UNDEFINED
			on_draw = FUNCTION
				LOCAL.w = width                  // width of the space available for displaying the displayed_element after adding scrollbars
				LOCAL.h = height                 // height of the space available for displaying the displayed_element after adding scrollbars
				LOCAL.dw = pixelwidth(displayed_element)   // width of the displayed_element
				LOCAL.dh = pixelheight(displayed_element)  // height of the displayed_element
				LOCAL.vscrollbar = false
				LOCAL.hscrollbar = false
				// determine whether we need a vertical scrollbar
				if value_type(vertical_scrollbar) == "STRUCTURE" && ( !optional_scrollbars || h < dh )
					vscrollbar = vertical_scrollbar.structure_type == "ARRAY" ? createSimpleScrollbar(w, h, vertical_scrollbar, true) : vertical_scrollbar
					w = w - pixelwidth(vscrollbar) - scrollbar_padding
				// determine whether we need a horizontal scrollbar
				if value_type(horizontal_scrollbar) == "STRUCTURE" && ( !optional_scrollbars || w < dw )
					hscrollbar = horizontal_scrollbar.structure_type == "ARRAY" ? createSimpleScrollbar(w, h, horizontal_scrollbar, false) : horizontal_scrollbar
					h = h - pixelheight(hscrollbar) - scrollbar_padding
					// check whether after adding the horizontal scrollbar we now need the vertical scrollbar (w, h, because the display area is no longer high enough to display the content). we don't have to check whether scrollbars are optional, they definitely are
					if vscrollbar == false && value_type(vertical_scrollbar) == "STRUCTURE" && h < dh
						vscrollbar = vertical_scrollbar.structure_type == "ARRAY" ? createSimpleScrollbar(w, h, vertical_scrollbar, true) : vertical_scrollbar
						w = w - pixelwidth(vscrollbar) - scrollbar_padding
					else
						vscrollbar.height = h   // the height needs to be reduced to make room for the horizontal scrollbar
				// add/remove the vertical scrollbar
				if vscrollbar != false
					vscrollbar.slider_max = dh - h
					// if the vertical scrollbar already exists, fetch the current state
					if component[2].structure_type == "SCROLLBAR"
						setSliderPosition(vscrollbar, component[2].slider_position)
						vscrollbar.slider_stepping = component[2].slider_stepping
						vscrollbar.slider_dragging = component[2].slider_dragging
						if vscrollbar.slider_dragging != UNDEFINED
							vscrollbar.component[0].state = PRESSED
						else
							vscrollbar.component[0].state = component[2].component[0].state
						if vscrollbar.component[1] != UNDEFINED && component[2].component[1] != UNDEFINED
							vscrollbar.component[1].state = component[2].component[1].state
						if vscrollbar.component[2] != UNDEFINED && component[2].component[2] != UNDEFINED
							vscrollbar.component[2].state = component[2].component[2].state
					component[2] = vscrollbar
				else
					component[2] = UNDEFINED
				// add/remove the horizontal scrollbar
				if hscrollbar != false
					hscrollbar.slider_max = dw - w
					// if the horizontal scrollbar already exists, fetch the current state
					if component[3].structure_type == "SCROLLBAR"
						setSliderPosition(hscrollbar, component[3].slider_position)
						hscrollbar.slider_stepping = component[3].slider_stepping
						hscrollbar.slider_dragging = component[3].slider_dragging
						if hscrollbar.slider_dragging != UNDEFINED
							hscrollbar.component[0].state = PRESSED
						else
							hscrollbar.component[0].state = component[3].component[0].state
						if hscrollbar.component[1] != UNDEFINED && component[3].component[1] != UNDEFINED
							hscrollbar.component[1].state = component[3].component[1].state
						if hscrollbar.component[3] != UNDEFINED && component[3].component[3] != UNDEFINED
							hscrollbar.component[3].state = component[3].component[3].state
					component[3] = hscrollbar
				else
					component[3] = UNDEFINED
				// add or remove the corner filler
				if hscrollbar != false && vscrollbar != false
					component[1] = corner_filler
				else
					component[1] = UNDEFINED
				// adjust the displayed content
				component[0].width = w
				component[0].height = h
				component[0].component.x = hscrollbar == false ? 0 : -hscrollbar.slider_position
				component[0].component.y = vscrollbar == false ? 0 : -vscrollbar.slider_position
				component[0].component.component = displayed_element
